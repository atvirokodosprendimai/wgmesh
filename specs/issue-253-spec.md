# Specification: Issue #253

## Classification
feature

## Deliverables
code + documentation

## Problem Analysis

Currently, the lighthouse has no DNS integration: it stores edge nodes with a `Location` field and a `PublicIP` field (defined in `pkg/lighthouse/types.go:86-96`), but it cannot generate DNS records or push them to any provider.  Sites also have a `Domain` field, but it is only used as an identifier — no geo-aware routing records are generated for it.

GeoDNS is the practical path to CDN-level edge routing without requiring BGP peering or IP prefix announcements.  The goal of this feature is to:

1. Map each edge's `Location` code to a geographic region.
2. Derive a set of DNS A/AAAA records that point each region to the nearest healthy edge.
3. Support at least one DNS provider (Cloudflare, as the most practical).
4. Provide a fallback zone-file export for self-hosted PowerDNS/BIND.
5. Exclude unhealthy edges (stale heartbeat, as defined by issue #247).

Relevant existing types in `pkg/lighthouse/types.go`:

```go
type Edge struct {
    ID            string    `json:"id"`
    Name          string    `json:"name"`
    Location      string    `json:"location"`   // Hetzner location code, e.g. "fsn1", "ash"
    MeshIP        string    `json:"mesh_ip"`
    PublicIP      string    `json:"public_ip"`  // Used as A record value
    Status        string    `json:"status"`     // "connected" / "disconnected"
    LastHeartbeat time.Time `json:"last_heartbeat"`
    SiteCount     int       `json:"site_count"`
    EnvoyVersion  string    `json:"envoy_version,omitempty"`
}

type Site struct {
    ID        string `json:"id"`
    OrgID     string `json:"org_id"`
    Domain    string `json:"domain"`
    DNSTarget string `json:"dns_target"`
    // ...
}
```

The store already provides `ListEdges(ctx)` and `ListAllSites(ctx)`.

## Proposed Approach

### Step 1 — Location-to-Region mapping (`pkg/lighthouse/geodns.go`)

Define a static mapping from Hetzner/common datacenter location codes to broad geographic regions:

```
"fsn1", "nbg1", "hel1" → "eu-central"
"ash"                   → "us-east"
"hil"                   → "us-west"
"sin"                   → "ap-southeast"
```

Any unknown location code falls back to the `"global"` pseudo-region (all edges are candidate fallbacks).

### Step 2 — Healthy-edge filtering

An edge is considered healthy when both of the following are true:
- `edge.Status == "connected"`
- `time.Since(edge.LastHeartbeat) <= heartbeatTTL` (suggested default: 90 s, consistent with issue #247 if/when merged; safe to hard-code until then)

Only healthy edges are included in generated records.

### Step 3 — Record generation (`GeoDNSGenerator`)

`GeoDNSGenerator` is a pure function object (no network I/O) that builds a `[]DNSRecord` slice from a list of edges.

```go
type DNSRecord struct {
    Name    string // fully-qualified domain, e.g. "example.com."
    Type    string // "A" or "AAAA"
    Value   string // IP address
    TTL     int    // seconds, default 60
    Region  string // geo-steering tag (provider-specific)
}
```

Logic:
1. Filter edges to healthy-only.
2. Group by region.
3. For each region, pick the edge with the most recent heartbeat as the primary record.
4. For regions with no edge, pick the globally most-recent healthy edge as a fallback record.
5. Emit one `DNSRecord` per region.

### Step 4 — Cloudflare provider (`pkg/lighthouse/dns_cloudflare.go`)

Implement `CloudflareDNSProvider` that calls the Cloudflare REST API:

- `PUT /zones/{zone_id}/dns_records/{record_id}` to update an existing record.
- `POST /zones/{zone_id}/dns_records` to create a new record (when no matching record exists).
- Record comment field set to `"wgmesh-managed"` to distinguish managed records.
- Auth via `Authorization: Bearer <cf_token>` header.

The provider must not delete records it did not create (identify by comment or tag).

### Step 5 — Zone-file export (`pkg/lighthouse/dns_zonefile.go`)

Write a `ZoneFileExporter` that serialises the `[]DNSRecord` slice to RFC 1035 zone file format.  The output can be piped directly to PowerDNS or BIND.

Example output for a site `example.com`:

```
; Generated by wgmesh lighthouse - do not edit manually
$TTL 60
@   IN  SOA  ns1.example.com. admin.example.com. (
            2024010100 ; serial
            3600       ; refresh
            900        ; retry
            604800     ; expire
            300 )      ; minimum TTL
@   IN  NS   ns1.example.com.

; GeoDNS records
example.com.  60  IN  A  203.0.113.10  ; eu-central
example.com.  60  IN  A  198.51.100.5  ; us-east
```

(GeoIP BIND views / PowerDNS Lua backend configuration are outside scope for this spec; only the record data is emitted.)

### Step 6 — API endpoints (`pkg/lighthouse/api.go`)

Add two new authenticated endpoints under site context:

| Method | Path | Description |
|--------|------|-------------|
| `GET` | `/v1/sites/{site_id}/dns/records` | Preview the DNS records that would be pushed. Returns `[]DNSRecord` as JSON. |
| `POST` | `/v1/sites/{site_id}/dns/sync` | Push records to the configured DNS provider. Returns a sync result summary. |

Request body for `POST /v1/sites/{site_id}/dns/sync`:

```json
{
  "provider": "cloudflare",    // or "zonefile"
  "zone_id": "<cf_zone_id>",   // required for cloudflare
  "cf_token": "<api_token>"    // required for cloudflare; not stored on server
}
```

The `cf_token` is accepted per-request and never persisted to the store.

### Step 7 — `DNSProviderConfig` (optional configuration in `Site`)

To support push-on-save in the future (out of scope here), no configuration is stored in `Site` for now.  The sync endpoint is always on-demand.

## Affected Files

### New files

| File | Purpose |
|------|---------|
| `pkg/lighthouse/geodns.go` | `GeoDNSGenerator`, location→region map, `DNSRecord` type, healthy-edge filter |
| `pkg/lighthouse/dns_cloudflare.go` | `CloudflareDNSProvider` implementation |
| `pkg/lighthouse/dns_zonefile.go` | `ZoneFileExporter` implementation |
| `pkg/lighthouse/geodns_test.go` | Unit tests for record generation logic |
| `pkg/lighthouse/dns_cloudflare_test.go` | Tests using an `httptest.Server` mock |
| `pkg/lighthouse/dns_zonefile_test.go` | Tests for zone-file serialisation |

### Modified files

| File | Change |
|------|--------|
| `pkg/lighthouse/api.go` | Register `GET /v1/sites/{site_id}/dns/records` and `POST /v1/sites/{site_id}/dns/sync` handlers; wire `GeoDNSGenerator` |
| `pkg/lighthouse/api_test.go` | Add HTTP-level tests for the two new endpoints |

No changes to `types.go`, `store.go`, `sync.go`, or `xds.go` are required.

## Test Strategy

### Unit tests (`geodns_test.go`)

Table-driven tests covering:

| Scenario | Expected outcome |
|----------|-----------------|
| Zero edges | Empty record slice, no panic |
| All edges unhealthy (stale heartbeat) | Empty record slice |
| One healthy edge, one region | Single A record pointing to that edge |
| Multiple edges same region | Most-recent heartbeat wins |
| Region with no edge | Falls back to globally nearest healthy edge |
| IPv6 `PublicIP` | Record type is `"AAAA"` |
| Mix of IPv4 and IPv6 edges | Correct type per record |
| Unknown location code | Mapped to `"global"` fallback bucket |

### Mock Cloudflare tests (`dns_cloudflare_test.go`)

Use `net/http/httptest.NewServer` to mock the Cloudflare API:

- Verify `POST` is called on first sync (no existing records).
- Verify `PUT` is called on subsequent sync (existing managed records).
- Verify unmanaged records are not touched.
- Verify auth header is sent correctly.
- Verify error is returned on non-2xx HTTP response.

### Zone-file tests (`dns_zonefile_test.go`)

- Golden-file test: compare generated output to a fixture.
- Verify serial number is derived from current timestamp (date-based `YYYYMMDDnn`).
- Verify comment lines include region name.

### API endpoint tests (`api_test.go`)

Using the existing `httptest`-based harness in `pkg/lighthouse/api_test.go`:

- `GET /v1/sites/{site_id}/dns/records`: returns 200 with a JSON array; empty array when no healthy edges.
- `POST /v1/sites/{site_id}/dns/sync` with `provider: "zonefile"`: returns 200 with zone-file text in body.
- `POST /v1/sites/{site_id}/dns/sync` with `provider: "cloudflare"` and a mock server URL: returns 200 with sync result.
- `POST /v1/sites/{site_id}/dns/sync` with missing `zone_id` for Cloudflare: returns 400.
- Auth: unauthenticated requests return 401; cross-org access returns 403.

## Estimated Complexity

**medium** (~1–2 days)

### Rationale

- New package-level file (`geodns.go`) is purely algorithmic — no external dependencies beyond stdlib.
- Cloudflare API integration is a single file using `net/http` (no new external library needed).
- Zone-file serialisation is trivial string formatting.
- API wiring follows the exact pattern already established in `api.go`.
- Main unknowns: how closely to align with issue #247's heartbeat TTL constant once it merges; can be handled with a local constant for now.

### Time breakdown

| Task | Estimate |
|------|---------|
| `geodns.go` (core logic + tests) | 3 h |
| `dns_cloudflare.go` (HTTP client + tests) | 3 h |
| `dns_zonefile.go` (serialiser + tests) | 1 h |
| API handler wiring + endpoint tests | 2 h |
| Documentation / OpenAPI spec update | 1 h |
| **Total** | **~10 h** |
