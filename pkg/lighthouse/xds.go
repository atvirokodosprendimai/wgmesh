package lighthouse

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"
)

// XDS generates Envoy configuration snapshots from the current site state.
// Instead of a full gRPC xDS server (which pulls in massive protobuf deps),
// we use Envoy's filesystem or REST config subscription. Edge Envoy nodes
// poll GET /v1/xds/config periodically, or we push via the mesh.
//
// This keeps the dependency footprint minimal while achieving the same result.
// Migration to full xDS gRPC is straightforward later.
type XDS struct {
	store      *Store
	mu         sync.RWMutex
	version    int64
	lastConfig []byte
}

// NewXDS creates a new xDS config generator.
func NewXDS(store *Store) *XDS {
	return &XDS{store: store}
}

// EnvoyCluster represents an upstream origin in Envoy config.
type EnvoyCluster struct {
	Name     string `json:"name"`
	Address  string `json:"address"`
	Port     int    `json:"port"`
	Protocol string `json:"protocol"`
}

// EnvoyRoute maps a domain to an upstream cluster.
type EnvoyRoute struct {
	Domain  string `json:"domain"`
	Cluster string `json:"cluster"`
	TLS     string `json:"tls"`
	SiteID  string `json:"site_id"`
}

// EnvoySnapshot is the full config pushed to edge Envoy nodes.
type EnvoySnapshot struct {
	Version   string         `json:"version"`
	Timestamp string         `json:"timestamp"`
	Clusters  []EnvoyCluster `json:"clusters"`
	Routes    []EnvoyRoute   `json:"routes"`
}

// BuildSnapshot generates an Envoy config snapshot from current site state.
func (x *XDS) BuildSnapshot(ctx context.Context) (*EnvoySnapshot, error) {
	sites, err := x.store.ListAllSites(ctx)
	if err != nil {
		return nil, fmt.Errorf("list sites for xDS: %w", err)
	}

	x.mu.Lock()
	x.version++
	version := x.version
	x.mu.Unlock()

	snap := &EnvoySnapshot{
		Version:   fmt.Sprintf("v%d", version),
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Clusters:  make([]EnvoyCluster, 0, len(sites)),
		Routes:    make([]EnvoyRoute, 0, len(sites)),
	}

	for _, site := range sites {
		if site.Status != SiteStatusActive && site.Status != SiteStatusPendingDNS && site.Status != SiteStatusPendingVerify {
			continue
		}

		clusterName := fmt.Sprintf("origin_%s", site.ID)
		snap.Clusters = append(snap.Clusters, EnvoyCluster{
			Name:     clusterName,
			Address:  site.Origin.MeshIP,
			Port:     site.Origin.Port,
			Protocol: site.Origin.Protocol,
		})
		snap.Routes = append(snap.Routes, EnvoyRoute{
			Domain:  site.Domain,
			Cluster: clusterName,
			TLS:     string(site.TLS),
			SiteID:  site.ID,
		})
	}

	// Cache the config
	data, _ := json.Marshal(snap)
	x.mu.Lock()
	x.lastConfig = data
	x.mu.Unlock()

	return snap, nil
}

// HandleConfig serves the current Envoy config snapshot.
// Edge nodes poll this endpoint to get their configuration.
func (x *XDS) HandleConfig(w http.ResponseWriter, r *http.Request) {
	snap, err := x.BuildSnapshot(r.Context())
	if err != nil {
		log.Printf("[xDS] build snapshot error: %v", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("X-Envoy-Config-Version", snap.Version)
	if err := json.NewEncoder(w).Encode(snap); err != nil {
		log.Printf("[xDS] write config: %v", err)
	}
}

// HandleCaddyConfig generates a Caddyfile for edge Caddy TLS sidecar.
// This produces a dynamic multi-domain Caddyfile from current sites.
func (x *XDS) HandleCaddyConfig(w http.ResponseWriter, r *http.Request) {
	sites, err := x.store.ListAllSites(r.Context())
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "text/plain")

	// Global options
	fmt.Fprintf(w, "# Auto-generated by lighthouse â€” %s\n", time.Now().UTC().Format(time.RFC3339))
	fmt.Fprintf(w, "# %d sites\n\n", len(sites))

	for _, site := range sites {
		if site.Status == SiteStatusDeleted || site.Status == SiteStatusSuspended {
			continue
		}

		upstream := fmt.Sprintf("%s://%s:%d", site.Origin.Protocol, site.Origin.MeshIP, site.Origin.Port)

		fmt.Fprintf(w, "%s {\n", site.Domain)
		fmt.Fprintf(w, "\treverse_proxy %s {\n", upstream)
		fmt.Fprintf(w, "\t\theader_up Host {upstream_hostport}\n")
		fmt.Fprintf(w, "\t\theader_up X-Real-IP {remote_host}\n")
		fmt.Fprintf(w, "\t\theader_up X-Forwarded-For {remote_host}\n")
		fmt.Fprintf(w, "\t\theader_up X-Site-ID %s\n", site.ID)
		fmt.Fprintf(w, "\t}\n")

		if site.TLS == TLSModeOff {
			fmt.Fprintf(w, "\t# TLS disabled for this site\n")
		}

		fmt.Fprintf(w, "\theader {\n")
		fmt.Fprintf(w, "\t\tX-Served-By {system.hostname}\n")
		fmt.Fprintf(w, "\t\tX-CDN cloudroof\n")
		fmt.Fprintf(w, "\t\t-Server\n")
		fmt.Fprintf(w, "\t}\n")

		fmt.Fprintf(w, "\tlog {\n")
		fmt.Fprintf(w, "\t\toutput stdout\n")
		fmt.Fprintf(w, "\t}\n")

		fmt.Fprintf(w, "}\n\n")
	}
}
