<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>wgmesh — Agent Pipeline Dashboard</title>
<style>
:root {
  --bg: #0d1117; --surface: #161b22; --border: #30363d;
  --text: #e6edf3; --muted: #8b949e; --accent: #58a6ff;
  --green: #3fb950; --red: #f85149; --yellow: #d29922; --purple: #bc8cff;
  --orange: #f0883e;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  background: var(--bg); color: var(--text); line-height: 1.5; padding: 1rem; }
a { color: var(--accent); text-decoration: none; }
a:hover { text-decoration: underline; }

.header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
.header h1 { font-size: 1.5rem; font-weight: 600; }
.header .subtitle { color: var(--muted); font-size: 0.875rem; }
.refresh-info { margin-left: auto; color: var(--muted); font-size: 0.75rem; }
.rate-info { color: var(--muted); font-size: 0.6875rem; }

.grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
.card { background: var(--surface); border: 1px solid var(--border); border-radius: 6px; padding: 1rem; }
.card h2 { font-size: 0.875rem; font-weight: 600; color: var(--muted); text-transform: uppercase;
  letter-spacing: 0.05em; margin-bottom: 0.75rem; }

.stat-row { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 0.5rem; }
.stat-label { color: var(--muted); font-size: 0.8125rem; }
.stat-value { font-size: 1.25rem; font-weight: 600; font-variant-numeric: tabular-nums; }
.stat-value.green { color: var(--green); }
.stat-value.red { color: var(--red); }
.stat-value.yellow { color: var(--yellow); }
.stat-value.purple { color: var(--purple); }
.stat-value.accent { color: var(--accent); }

.pipeline-table { width: 100%; border-collapse: collapse; font-size: 0.8125rem; }
.pipeline-table th { text-align: left; color: var(--muted); font-weight: 500;
  padding: 0.5rem 0.75rem; border-bottom: 1px solid var(--border); }
.pipeline-table td { padding: 0.5rem 0.75rem; border-bottom: 1px solid var(--border); vertical-align: top; }
.pipeline-table tr:last-child td { border-bottom: none; }

.badge { display: inline-block; padding: 0.125rem 0.5rem; border-radius: 999px;
  font-size: 0.6875rem; font-weight: 600; white-space: nowrap; }
.badge-green { background: rgba(63,185,80,0.15); color: var(--green); }
.badge-red { background: rgba(248,81,73,0.15); color: var(--red); }
.badge-yellow { background: rgba(210,153,34,0.15); color: var(--yellow); }
.badge-purple { background: rgba(188,140,255,0.15); color: var(--purple); }
.badge-blue { background: rgba(88,166,255,0.15); color: var(--accent); }
.badge-muted { background: rgba(139,148,158,0.15); color: var(--muted); }
.badge-orange { background: rgba(240,136,62,0.15); color: var(--orange); }

.run-list { list-style: none; }
.run-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.375rem 0;
  border-bottom: 1px solid var(--border); font-size: 0.8125rem; }
.run-item:last-child { border-bottom: none; }
.run-icon { width: 16px; height: 16px; flex-shrink: 0; }

.spinner { display: inline-block; width: 14px; height: 14px; border: 2px solid var(--border);
  border-top-color: var(--yellow); border-radius: 50%; animation: spin 0.8s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }

/* Impact cards */
.impact-card { background: var(--surface); border: 1px solid var(--border); border-radius: 6px;
  padding: 1rem; margin-bottom: 0.75rem; }
.impact-title { font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem; }
.impact-meta { font-size: 0.75rem; color: var(--muted); margin-bottom: 0.5rem; }
.impact-files { font-size: 0.75rem; margin-top: 0.5rem; }
.impact-file { display: inline-block; padding: 0.125rem 0.375rem; border-radius: 3px;
  background: rgba(88,166,255,0.1); color: var(--accent); margin: 0.125rem; font-family: monospace; }
.impact-stat { display: inline-flex; align-items: center; gap: 0.25rem; font-size: 0.75rem;
  margin-right: 0.75rem; }
.diff-add { color: var(--green); }
.diff-del { color: var(--red); }

.empty { color: var(--muted); font-style: italic; padding: 1rem 0; text-align: center; }
.loading { text-align: center; padding: 2rem; color: var(--muted); }

.full-width { grid-column: 1 / -1; }
.overflow-x { overflow-x: auto; }

.category-tag { display: inline-block; padding: 0.125rem 0.375rem; border-radius: 3px;
  font-size: 0.6875rem; font-weight: 600; margin-right: 0.25rem; }
.cat-bugfix { background: rgba(248,81,73,0.15); color: var(--red); }
.cat-test { background: rgba(188,140,255,0.15); color: var(--purple); }
.cat-security { background: rgba(240,136,62,0.15); color: var(--orange); }
.cat-feature { background: rgba(63,185,80,0.15); color: var(--green); }
.cat-infra { background: rgba(88,166,255,0.15); color: var(--accent); }
.cat-refactor { background: rgba(210,153,34,0.15); color: var(--yellow); }

/* Business impact section */
.biz-impact { background: linear-gradient(135deg, rgba(88,166,255,0.05), rgba(63,185,80,0.05));
  border: 1px solid var(--border); border-radius: 6px; padding: 1.25rem; }
.biz-impact h2 { font-size: 0.875rem; font-weight: 600; color: var(--accent); text-transform: uppercase;
  letter-spacing: 0.05em; margin-bottom: 1rem; }
.biz-row { display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem; }
.biz-metric { flex: 1; min-width: 180px; background: var(--surface); border-radius: 6px;
  padding: 0.75rem 1rem; border: 1px solid var(--border); }
.biz-metric-label { font-size: 0.6875rem; color: var(--muted); text-transform: uppercase;
  letter-spacing: 0.04em; margin-bottom: 0.25rem; }
.biz-metric-value { font-size: 1.5rem; font-weight: 700; font-variant-numeric: tabular-nums; }
.biz-metric-detail { font-size: 0.75rem; color: var(--muted); margin-top: 0.125rem; }
.biz-narrative { font-size: 0.8125rem; line-height: 1.6; color: var(--text); }
.biz-narrative p { margin-bottom: 0.5rem; }
.biz-highlight { color: var(--green); font-weight: 600; }
.biz-warn { color: var(--yellow); font-weight: 600; }

footer { text-align: center; color: var(--muted); font-size: 0.75rem; padding: 2rem 0 1rem; }

/* ── Traction Roadmap ── */
.section-divider { margin: 2rem 0 1.25rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border); }
.section-divider h2 { font-size: 1rem; font-weight: 600; color: var(--accent); margin: 0; }
.section-divider p { font-size: 0.75rem; color: var(--muted); margin-top: 0.25rem; }

/* MSC Progress */
.msc-bar { position: relative; background: var(--surface); border: 1px solid var(--border);
  border-radius: 6px; padding: 1.25rem 1rem 1rem; }
.msc-bar h3 { font-size: 0.8125rem; color: var(--muted); text-transform: uppercase;
  letter-spacing: 0.04em; margin-bottom: 0.75rem; }
.msc-track { position: relative; height: 28px; background: rgba(139,148,158,0.1);
  border-radius: 14px; overflow: visible; margin-bottom: 0.75rem; }
.msc-fill { position: absolute; left: 0; top: 0; height: 100%; border-radius: 14px;
  background: linear-gradient(90deg, var(--accent), var(--green));
  transition: width 0.5s ease; min-width: 2px; }
.msc-markers { display: flex; justify-content: space-between; font-size: 0.6875rem; color: var(--muted); }
.msc-marker { text-align: center; flex: 1; }
.msc-marker strong { display: block; font-size: 0.8125rem; color: var(--text); }
.msc-current { font-size: 1.5rem; font-weight: 700; color: var(--accent); }

/* Customer Factory funnel */
.funnel { display: flex; gap: 0; margin-bottom: 0.5rem; }
.funnel-stage { flex: 1; padding: 0.75rem 0.5rem; text-align: center; position: relative;
  border-right: 1px solid var(--bg); }
.funnel-stage:last-child { border-right: none; }
.funnel-stage .stage-name { font-size: 0.6875rem; font-weight: 600; text-transform: uppercase;
  letter-spacing: 0.04em; margin-bottom: 0.25rem; }
.funnel-stage .stage-metric { font-size: 0.75rem; color: var(--muted); margin-bottom: 0.25rem; }
.funnel-stage .stage-status { font-size: 0.6875rem; font-weight: 600; }
.funnel-stage.blocked { background: rgba(248,81,73,0.08); }
.funnel-stage.blocked .stage-name { color: var(--red); }
.funnel-stage.ready { background: rgba(63,185,80,0.08); }
.funnel-stage.ready .stage-name { color: var(--green); }
.funnel-stage.waiting { background: rgba(139,148,158,0.06); }
.funnel-stage.waiting .stage-name { color: var(--muted); }
.constraint-arrow { display: block; text-align: center; font-size: 0.6875rem; color: var(--red);
  font-weight: 600; margin-top: 0.25rem; }

/* Horizon cards */
.horizon-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
@media (max-width: 768px) { .horizon-grid { grid-template-columns: 1fr; } }
.horizon-card { background: var(--surface); border: 1px solid var(--border); border-radius: 6px;
  padding: 1rem; }
.horizon-card h3 { font-size: 0.8125rem; font-weight: 600; margin-bottom: 0.5rem; }
.horizon-card.now { border-left: 3px solid var(--green); }
.horizon-card.now h3 { color: var(--green); }
.horizon-card.next { border-left: 3px solid var(--yellow); }
.horizon-card.next h3 { color: var(--yellow); }
.horizon-card.later { border-left: 3px solid var(--muted); }
.horizon-card.later h3 { color: var(--muted); }
.horizon-card ul { list-style: none; font-size: 0.8125rem; }
.horizon-card li { padding: 0.25rem 0; padding-left: 1rem; position: relative; }
.horizon-card li::before { content: ''; position: absolute; left: 0; top: 0.6rem;
  width: 6px; height: 6px; border-radius: 50%; background: var(--border); }
.horizon-card.now li::before { background: var(--green); }
.horizon-card.next li::before { background: var(--yellow); }
.horizon-card.later li::before { background: var(--muted); }

/* Sponsor section */
.sponsor-card { background: linear-gradient(135deg, rgba(188,140,255,0.06), rgba(88,166,255,0.06));
  border: 1px solid var(--border); border-radius: 6px; padding: 1.25rem; }
.sponsor-card h2 { font-size: 0.875rem; font-weight: 600; color: var(--purple); text-transform: uppercase;
  letter-spacing: 0.05em; margin-bottom: 0.75rem; }
.tier-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; }
.tier { background: var(--surface); border: 1px solid var(--border); border-radius: 6px; padding: 1rem; }
.tier h3 { font-size: 0.875rem; font-weight: 600; margin-bottom: 0.125rem; }
.tier .tier-price { font-size: 1.25rem; font-weight: 700; color: var(--accent); margin-bottom: 0.5rem; }
.tier ul { list-style: none; font-size: 0.8125rem; }
.tier li { padding: 0.25rem 0; padding-left: 1.25rem; position: relative; color: var(--text); }
.tier li::before { content: '\2713'; position: absolute; left: 0; color: var(--green); font-weight: 700; }
.tier.featured { border-color: var(--purple); }
.tier.featured h3 { color: var(--purple); }
.sponsor-note { font-size: 0.75rem; color: var(--muted); margin-top: 1rem; line-height: 1.5; }
.sponsor-note a { color: var(--accent); }

/* Capability table */
.cap-table { width: 100%; border-collapse: collapse; font-size: 0.8125rem; }
.cap-table th { text-align: left; color: var(--muted); font-weight: 500;
  padding: 0.5rem 0.75rem; border-bottom: 1px solid var(--border); }
.cap-table td { padding: 0.5rem 0.75rem; border-bottom: 1px solid var(--border); }
.cap-table tr:last-child td { border-bottom: none; }
.cap-done { color: var(--green); }
.cap-blocked { color: var(--red); font-weight: 600; }
.cap-partial { color: var(--yellow); }
.cap-later { color: var(--muted); }
</style>
</head>
<body>

<div class="header">
  <h1>wgmesh Agent Pipeline</h1>
  <span class="subtitle">Autonomous AI coding pipeline — issue to merge</span>
  <div style="margin-left:auto;text-align:right">
    <span class="refresh-info">Auto-refreshes every 5m &middot; <span id="last-update">loading...</span></span>
    <div class="rate-info">API: <span id="rate-remaining">?</span> remaining (<span id="api-mode">proxy</span>) &middot; Cache hits: <span id="cache-stats">0/0</span></div>
  </div>
</div>

<!-- ══════════════════════════════════════════════════════════════════
     TRACTION ROADMAP — outcomes, not outputs
     ══════════════════════════════════════════════════════════════════ -->

<div class="section-divider">
  <h2>Traction Roadmap &mdash; cloudroof.eu</h2>
  <p>Zero-infrastructure anycast CDN built on WireGuard mesh. Measuring outcomes, not outputs.</p>
  <p style="margin-top:0.5rem;font-size:0.8125rem;color:var(--muted)">
    wgmesh live:
    <span id="traction-wgmesh-version" style="color:var(--accent);font-family:monospace">loading...</span>
    &middot; open issues: <span id="traction-open-issues" style="color:var(--yellow)">-</span>
    &middot; open PRs: <span id="traction-open-prs" style="color:var(--accent)">-</span>
    &middot; Goose pass rate: <span id="traction-goose-rate" style="color:var(--green)">-</span>
    &middot; last merge: <span id="traction-last-merge" style="color:var(--muted)">-</span>
  </p>
</div>

<!-- MSC Progress -->
<div class="msc-bar" style="margin-bottom:1.25rem">
  <h3>Minimum Success Criteria &mdash; 3-Year Target: $100K ARR</h3>
  <div style="display:flex;align-items:baseline;gap:0.75rem;margin-bottom:0.75rem">
    <span class="msc-current">0</span>
    <span style="color:var(--muted);font-size:0.875rem">of 1 customer (90-day target)</span>
  </div>
  <div class="msc-track">
    <div class="msc-fill" style="width:1%"></div>
  </div>
  <div class="msc-markers">
    <div class="msc-marker"><strong>0</strong>NOW</div>
    <div class="msc-marker"><strong>1</strong>90d</div>
    <div class="msc-marker"><strong>4</strong>Year 1</div>
    <div class="msc-marker"><strong>42</strong>Year 2</div>
    <div class="msc-marker"><strong>420</strong>Year 3 (MSC)</div>
  </div>
</div>

<!-- Customer Factory -->
<div class="card full-width" style="margin-bottom:1.25rem">
  <h2>Customer Factory</h2>
  <div class="funnel">
    <div class="funnel-stage waiting">
      <div class="stage-name">Acquisition</div>
      <div class="stage-metric">Visit cloudroof.eu</div>
      <div class="stage-status" style="color:var(--muted)">No analytics yet</div>
    </div>
    <div class="funnel-stage blocked">
      <div class="stage-name">Activation</div>
      <div class="stage-metric">Deploy mesh + serve HTTP</div>
      <div class="stage-status" style="color:var(--yellow)">IN PROGRESS</div>
      <span class="constraint-arrow">&#9650; needs CLI: <a href="https://github.com/atvirokodosprendimai/wgmesh/issues/257">#257</a> + <a href="https://github.com/atvirokodosprendimai/wgmesh/issues/259">#259</a></span>
    </div>
    <div class="funnel-stage waiting">
      <div class="stage-name">Revenue</div>
      <div class="stage-metric">Paid subscriber</div>
      <div class="stage-status" style="color:var(--muted)">0</div>
    </div>
    <div class="funnel-stage waiting">
      <div class="stage-name">Retention</div>
      <div class="stage-metric">Running after 30d</div>
      <div class="stage-status" style="color:var(--muted)">N/A</div>
    </div>
    <div class="funnel-stage waiting">
      <div class="stage-name">Referral</div>
      <div class="stage-metric">Invites another user</div>
      <div class="stage-status" style="color:var(--muted)">N/A</div>
    </div>
  </div>
  <div style="font-size:0.75rem;color:var(--muted);margin-top:0.5rem">
    80% of effort goes to the single biggest constraint. Currently: <strong style="color:var(--yellow)">Edge Bootstrap CLI</strong> &mdash; lighthouse + Caddy config generation exist, need single-command edge setup (<a href="https://github.com/atvirokodosprendimai/wgmesh/issues/257">#257</a>).
  </div>
</div>

<!-- NOW / NEXT / LATER -->
<div class="horizon-grid" style="margin-bottom:1.25rem">
  <div class="horizon-card now">
    <h3>NOW &mdash; 90 days</h3>
    <ul>
      <li><s>Build edge proxy config generation</s> &check; <code>pkg/lighthouse/xds.go</code></li>
      <li><code>wgmesh edge init</code> &rarr; single-command edge bootstrap (<a href="https://github.com/atvirokodosprendimai/wgmesh/issues/257">#257</a>)</li>
      <li><code>wgmesh origin register</code> &rarr; origin self-announce (<a href="https://github.com/atvirokodosprendimai/wgmesh/issues/259">#259</a>)</li>
      <li>Edge heartbeats + health checks (<a href="https://github.com/atvirokodosprendimai/wgmesh/issues/247">#247</a>, <a href="https://github.com/atvirokodosprendimai/wgmesh/issues/248">#248</a>)</li>
      <li>End-to-end: <code>wgmesh init</code> &rarr; serving HTTP in &lt;5 min</li>
      <li>1 real user deploys mesh + serves traffic</li>
      <li><a href="https://rentahuman.ai">RentAHuman.ai</a>: hire beta tester for field validation</li>
    </ul>
  </div>
  <div class="horizon-card next">
    <h3>NEXT &mdash; 6 months</h3>
    <ul>
      <li>4 paying customers ($20/mo)</li>
      <li>GeoDNS routing (<a href="https://github.com/atvirokodosprendimai/wgmesh/issues/253">#253</a>)</li>
      <li>Multi-origin failover (<a href="https://github.com/atvirokodosprendimai/wgmesh/issues/254">#254</a>)</li>
      <li>DNS verification loop (<a href="https://github.com/atvirokodosprendimai/wgmesh/issues/250">#250</a>)</li>
      <li>Monitoring dashboard for mesh operators</li>
      <li>RentAHuman: humans deploy PoP nodes in datacenters</li>
    </ul>
  </div>
  <div class="horizon-card later">
    <h3>LATER &mdash; 18 months</h3>
    <ul>
      <li>42 customers &rarr; $10K ARR</li>
      <li>BGP anycast for real multi-region routing</li>
      <li>Self-serve signup + billing</li>
      <li>RentAHuman marketplace for managed PoP operators</li>
      <li>LLM Agent Evaluation System (DORA-inspired)</li>
    </ul>
  </div>
</div>

<!-- ══════════════════════════════════════════════════════════════════
     SPONSOR BENEFITS
     ══════════════════════════════════════════════════════════════════ -->

<div class="sponsor-card" style="margin-bottom:1.5rem">
  <h2>Sponsor Benefits</h2>
  <div class="tier-grid">
    <div class="tier">
      <h3>Contributor</h3>
      <div class="tier-price">$5/mo</div>
      <ul>
        <li>Name in SPONSORS.md</li>
        <li>Sponsor badge on GitHub profile</li>
        <li>Early access to releases</li>
        <li>Priority issue triage</li>
      </ul>
    </div>
    <div class="tier featured">
      <h3>Edge Node</h3>
      <div class="tier-price">$20/mo</div>
      <ul>
        <li>Everything in Contributor</li>
        <li>1 free cloudroof.eu CDN node (when launched)</li>
        <li>Private Discord/Matrix channel</li>
        <li>Vote on roadmap priorities</li>
        <li>Logo on project README</li>
      </ul>
    </div>
    <div class="tier">
      <h3>Mesh Operator</h3>
      <div class="tier-price">$100/mo</div>
      <ul>
        <li>Everything in Edge Node</li>
        <li>5 free CDN nodes</li>
        <li>Direct Slack/email support</li>
        <li>Custom feature requests</li>
        <li>Quarterly architecture review call</li>
      </ul>
    </div>
  </div>
  <div class="sponsor-note">
    Sponsorship is verified automatically via
    <a href="https://github.com/sponsors">GitHub Sponsors</a>.
    Sponsor benefits activate within minutes of your first payment via the
    <a href="https://docs.github.com/en/sponsors/integrating-with-github-sponsors/getting-started-with-the-sponsors-graphql-api">Sponsors GraphQL API</a>.
    <br>
    Not on GitHub? Any verifiable recurring payment (Open Collective, Patreon, direct transfer)
    qualifies &mdash; <a href="https://github.com/atvirokodosprendimai/wgmesh/issues/new?title=Sponsor+verification&labels=sponsor">open an issue</a> with your receipt.
  </div>
</div>

<!-- ══════════════════════════════════════════════════════════════════
     PIPELINE OPERATIONS — live data from GitHub API
     ══════════════════════════════════════════════════════════════════ -->

<div class="section-divider">
  <h2>Pipeline Operations</h2>
  <p>Live metrics from the autonomous AI coding pipeline (issue &rarr; Copilot spec &rarr; Goose impl &rarr; auto-merge).</p>
</div>

<!-- DORA metrics row -->
<div class="grid" id="dora-section">
  <div class="card">
    <h2>Deployment Frequency</h2>
    <div class="stat-row">
      <span class="stat-label">Merged PRs (7d)</span>
      <span class="stat-value green" id="dora-freq">-</span>
    </div>
  </div>
  <div class="card">
    <h2>Lead Time</h2>
    <div class="stat-row">
      <span class="stat-label">Avg PR open &rarr; merge</span>
      <span class="stat-value accent" id="dora-lead">-</span>
    </div>
  </div>
  <div class="card">
    <h2>Code Impact (7d)</h2>
    <div class="stat-row">
      <span class="stat-label">Lines added</span>
      <span class="stat-value green" id="impact-additions">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Lines removed</span>
      <span class="stat-value red" id="impact-deletions">-</span>
    </div>
  </div>
  <div class="card">
    <h2>Goose Success Rate</h2>
    <div class="stat-row">
      <span class="stat-label">Builds (7d)</span>
      <span class="stat-value green" id="dora-success">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Active / Open issues</span>
      <span class="stat-value yellow" id="dora-active">-</span>
    </div>
  </div>
</div>

<!-- Business / Product Impact -->
<div class="grid">
  <div class="biz-impact full-width">
    <h2>Product Impact Summary</h2>
    <div class="biz-row" id="biz-metrics">
      <div class="biz-metric">
        <div class="biz-metric-label">Reliability</div>
        <div class="biz-metric-value green" id="biz-reliability">-</div>
        <div class="biz-metric-detail" id="biz-reliability-detail">bugs fixed this week</div>
      </div>
      <div class="biz-metric">
        <div class="biz-metric-label">Security Posture</div>
        <div class="biz-metric-value" id="biz-security" style="color:var(--orange)">-</div>
        <div class="biz-metric-detail" id="biz-security-detail">vulnerabilities addressed</div>
      </div>
      <div class="biz-metric">
        <div class="biz-metric-label">Release Confidence</div>
        <div class="biz-metric-value purple" id="biz-quality">-</div>
        <div class="biz-metric-detail" id="biz-quality-detail">test files added</div>
      </div>
      <div class="biz-metric">
        <div class="biz-metric-label">Delivery Velocity</div>
        <div class="biz-metric-value accent" id="biz-velocity">-</div>
        <div class="biz-metric-detail" id="biz-velocity-detail">avg time to ship</div>
      </div>
    </div>
    <div class="biz-narrative" id="biz-narrative">
      <p style="color:var(--muted)">Loading product impact analysis...</p>
    </div>
  </div>
</div>

<!-- mem0 Memory System -->
<div class="grid">
  <div class="card">
    <h2>mem0 Agent Memory</h2>
    <div class="stat-row">
      <span class="stat-label">Status</span>
      <span class="stat-value" id="mem0-status" style="font-size:0.875rem">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Retrieve step (last run)</span>
      <span class="stat-value accent" id="mem0-retrieved">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Save step (last run)</span>
      <span class="stat-value green" id="mem0-saved">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Cache</span>
      <span class="stat-value" id="mem0-cache" style="font-size:0.875rem">-</span>
    </div>
  </div>
  <div class="card">
    <h2>mem0 Run History</h2>
    <div style="font-size:0.8125rem;color:var(--muted);margin-bottom:0.5rem">
      Memory retrieval/save results from recent Goose builds
    </div>
    <ul class="run-list" id="mem0-history">
      <li class="loading">Loading...</li>
    </ul>
  </div>
</div>

<!-- What was actually built — the main event -->
<div class="grid">
  <div class="card full-width">
    <h2>What the Pipeline Built — Recent Merged Changes</h2>
    <div id="impact-list">
      <div class="loading">Loading merged PR details...</div>
    </div>
  </div>
</div>

<!-- Active pipeline items -->
<div class="grid">
  <div class="card full-width">
    <h2>Pipeline Tracker — Active Issues</h2>
    <div class="overflow-x">
      <table class="pipeline-table" id="pipeline-tracker">
        <thead>
          <tr>
            <th>Issue</th>
            <th>Type</th>
            <th>Triage</th>
            <th>Spec PR</th>
            <th>Goose Build</th>
            <th>Impl PR</th>
            <th>Merged</th>
            <th>Age</th>
          </tr>
        </thead>
        <tbody>
          <tr><td colspan="8" class="loading">Loading pipeline data...</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Live workflow runs -->
<div class="grid">
  <div class="card">
    <h2>Active Workflow Runs</h2>
    <ul class="run-list" id="active-runs">
      <li class="loading">Loading...</li>
    </ul>
  </div>
  <div class="card">
    <h2>Recent Completions</h2>
    <ul class="run-list" id="recent-runs">
      <li class="loading">Loading...</li>
    </ul>
  </div>
</div>

<!-- ══════════════════════════════════════════════════════════════════
     TECHNICAL STATUS — capability readiness
     ══════════════════════════════════════════════════════════════════ -->

<div class="section-divider">
  <h2>Technical Capability Status</h2>
  <p>What's built, what's missing, and what blocks traction.</p>
</div>

<div class="card full-width" style="margin-bottom:1.5rem">
  <div class="overflow-x">
    <table class="cap-table">
      <thead>
        <tr>
          <th>Capability</th>
          <th>Status</th>
          <th>Package</th>
          <th>Blocks Traction?</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Mesh Networking</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>pkg/daemon</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>Node Deployment (SSH)</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>pkg/mesh, pkg/ssh</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>NAT Traversal</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>pkg/daemon</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>Route Advertising</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>pkg/daemon/routes</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>Auto-discovery (4 layers)</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>pkg/discovery</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>Security (AES-256-GCM, HKDF, Dandelion++)</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>pkg/crypto, pkg/privacy</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>CLI UX</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>main.go</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>Multi-platform binaries</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>.github/workflows</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>RPC Socket Interface</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>pkg/rpc</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>Lighthouse CDN Control Plane</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>pkg/lighthouse</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>Edge Proxy (Caddyfile generation)</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>pkg/lighthouse/xds.go</code></td>
          <td>&mdash;</td>
        </tr>
        <tr>
          <td>Federated State Sync (LWW CRDT)</td>
          <td class="cap-done">&#10003; Implemented</td>
          <td><code>pkg/lighthouse/sync.go</code></td>
          <td>&mdash;</td>
        </tr>
        <tr style="background:rgba(248,81,73,0.05)">
          <td><strong>Edge Bootstrap CLI</strong></td>
          <td class="cap-blocked">&#10007; Not Started</td>
          <td><a href="https://github.com/atvirokodosprendimai/wgmesh/issues/257">#257</a></td>
          <td class="cap-blocked">YES &mdash; #1 blocker (NOW)</td>
        </tr>
        <tr style="background:rgba(248,81,73,0.05)">
          <td><strong>Origin Registration CLI</strong></td>
          <td class="cap-blocked">&#10007; Not Started</td>
          <td><a href="https://github.com/atvirokodosprendimai/wgmesh/issues/259">#259</a></td>
          <td class="cap-blocked">YES &mdash; #1 blocker (NOW)</td>
        </tr>
        <tr>
          <td>Edge Heartbeats</td>
          <td class="cap-blocked">&#10007; Not Started</td>
          <td><a href="https://github.com/atvirokodosprendimai/wgmesh/issues/247">#247</a></td>
          <td class="cap-partial">Yes (NOW)</td>
        </tr>
        <tr>
          <td>HTTP Health Checks</td>
          <td class="cap-blocked">&#10007; Not Started</td>
          <td><a href="https://github.com/atvirokodosprendimai/wgmesh/issues/248">#248</a></td>
          <td class="cap-partial">Yes (NOW)</td>
        </tr>
        <tr>
          <td>Origin Lockdown</td>
          <td class="cap-partial">&#9888; Partial</td>
          <td><code>pkg/daemon</code></td>
          <td class="cap-partial">Yes (NOW)</td>
        </tr>
        <tr>
          <td>GeoDNS Routing</td>
          <td class="cap-blocked">&#10007; Not Started</td>
          <td><a href="https://github.com/atvirokodosprendimai/wgmesh/issues/253">#253</a></td>
          <td class="cap-later">Yes (NEXT phase)</td>
        </tr>
        <tr>
          <td>Multi-origin Failover</td>
          <td class="cap-blocked">&#10007; Not Started</td>
          <td><a href="https://github.com/atvirokodosprendimai/wgmesh/issues/254">#254</a></td>
          <td class="cap-later">Yes (NEXT phase)</td>
        </tr>
        <tr>
          <td>BGP Anycast</td>
          <td class="cap-blocked">&#10007; Not Started</td>
          <td>&mdash;</td>
          <td class="cap-later">Yes (LATER phase)</td>
        </tr>
      </tbody>
    </table>
  </div>
  <div style="font-size:0.75rem;color:var(--muted);margin-top:0.75rem">
    <span class="cap-done">&#10003;</span> = ready &nbsp;&nbsp;
    <span class="cap-partial">&#9888;</span> = partial &nbsp;&nbsp;
    <span class="cap-blocked">&#10007;</span> = missing &nbsp;&nbsp;
    Red background = blocks current traction target
  </div>
</div>

<footer>
  wgmesh Agent Pipeline Dashboard &middot;
  <a href="https://github.com/atvirokodosprendimai/wgmesh">Repository</a> &middot;
  <a href="https://cloudroof.eu">cloudroof.eu</a> &middot;
   <span id="footer-mode">Data via chimney proxy (authenticated, 5,000 req/hr)</span>
</footer>

<script>
const OWNER = 'atvirokodosprendimai';
const REPO = 'wgmesh';
// Use chimney proxy for GitHub API — server-side caching with authenticated token (5,000 req/hr).
// Falls back to direct GitHub API if proxy is unreachable (e.g., local development).
const CHIMNEY_PROXY = `${window.location.origin}/api/github`;
const DIRECT_API = `https://api.github.com/repos/${OWNER}/${REPO}`;
let API = CHIMNEY_PROXY;
let usingProxy = true;

let rateLimitRemaining = null;
let rateLimitReset = null;
let paused = false;
let cacheHits = 0;
let cacheMisses = 0;

// ── ETag cache with localStorage persistence ──
// Chimney proxy (and GitHub) returns 304 Not Modified for conditional
// requests — these do NOT count against the rate limit.
const CACHE_KEY = 'wgmesh-dash-cache';
const CACHE_VERSION = 1;
let etagCache = {};

function loadCache() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return;
    const parsed = JSON.parse(raw);
    if (parsed._v !== CACHE_VERSION) { localStorage.removeItem(CACHE_KEY); return; }
    // Evict entries older than 1 hour to keep storage lean
    const cutoff = Date.now() - 3600000;
    for (const [k, v] of Object.entries(parsed)) {
      if (k === '_v') continue;
      if (v.ts && v.ts > cutoff) etagCache[k] = v;
    }
  } catch { /* corrupt cache — ignore */ }
}

function saveCache() {
  try {
    const obj = { _v: CACHE_VERSION };
    for (const [k, v] of Object.entries(etagCache)) obj[k] = v;
    localStorage.setItem(CACHE_KEY, JSON.stringify(obj));
  } catch { /* quota exceeded or private mode — ignore */ }
}

loadCache();

// Serialize proxy→fallback transition so concurrent ghFetch calls don't all trigger it
let fallbackInFlight = null;

function switchToDirectAPI() {
  if (!usingProxy) return; // already switched
  console.warn('Chimney proxy unreachable, falling back to direct GitHub API');
  API = DIRECT_API;
  usingProxy = false;
  // Update footer to reflect actual data source
  const footerEl = document.getElementById('footer-mode');
  if (footerEl) footerEl.textContent = 'Data via direct GitHub API (unauthenticated, 60 req/hr)';
}

// Fetch with conditional requests (ETag/304), rate limit tracking, and 403 backoff.
// Uses chimney proxy (authenticated, server-cached) with fallback to direct GitHub API.
async function ghFetch(path) {
  if (paused) throw new Error('Rate limited — waiting for reset');
  const url = `${API}${path}`;
  const headers = { 'Accept': 'application/vnd.github+json' };

  // Add If-None-Match header if we have a cached ETag for this path
  const cached = etagCache[path];
  if (cached && cached.etag) {
    headers['If-None-Match'] = cached.etag;
  }

  let res;
  try {
    res = await fetch(url, { headers, cache: 'no-store' });
  } catch (err) {
    // Proxy unreachable — fall back to direct GitHub API (local dev).
    // Serialize the transition: if another concurrent call is already switching,
    // wait for it to finish, then retry with the new API base.
    if (usingProxy || fallbackInFlight) {
      if (!fallbackInFlight) {
        fallbackInFlight = (async () => {
          switchToDirectAPI();
        })();
      }
      await fallbackInFlight;
      fallbackInFlight = null;
      const fallbackUrl = `${API}${path}`;
      res = await fetch(fallbackUrl, { headers, cache: 'no-store' });
    } else {
      throw err;
    }
  }

  // Track rate limit
  const remaining = res.headers.get('x-ratelimit-remaining');
  const reset = res.headers.get('x-ratelimit-reset');
  if (remaining !== null) {
    rateLimitRemaining = parseInt(remaining, 10);
    const el = document.getElementById('rate-remaining');
    if (el) el.textContent = rateLimitRemaining;
  }
  if (reset) rateLimitReset = parseInt(reset, 10) * 1000;
  const modeEl = document.getElementById('api-mode');
  if (modeEl) modeEl.textContent = usingProxy ? 'proxy 5k/hr' : 'direct 60/hr';
  const footerEl = document.getElementById('footer-mode');
  if (footerEl) footerEl.textContent = usingProxy
    ? 'Data via chimney proxy (authenticated, 5,000 req/hr)'
    : 'Data via direct GitHub API (unauthenticated, 60 req/hr)';

  // Update cache stats display
  const statsEl = document.getElementById('cache-stats');
  if (statsEl) statsEl.textContent = `${cacheHits}/${cacheHits + cacheMisses}`;

  if (res.status === 403 || res.status === 429) {
    paused = true;
    const waitMs = rateLimitReset ? Math.max(rateLimitReset - Date.now(), 60000) : 60000;
    const waitMin = Math.ceil(waitMs / 60000);
    document.getElementById('last-update').textContent =
      `Rate limited — resuming in ~${waitMin}min`;
    setTimeout(() => { paused = false; }, waitMs);
    throw new Error(`Rate limited (${res.status}), pausing ${waitMin}min`);
  }

  // 304 Not Modified — return cached data (free! doesn't count against rate limit)
  if (res.status === 304 && cached && cached.data) {
    cacheHits++;
    return cached.data;
  }

  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);

  cacheMisses++;
  const data = await res.json();

  // Store response with ETag for future conditional requests
  const etag = res.headers.get('etag');
  if (etag) {
    etagCache[path] = { etag, data, ts: Date.now() };
    // Debounce localStorage writes — save after all fetches in a cycle
    clearTimeout(ghFetch._saveTimer);
    ghFetch._saveTimer = setTimeout(saveCache, 2000);
  }

  return data;
}

function timeAgo(dateStr) {
  const seconds = Math.floor((Date.now() - new Date(dateStr).getTime()) / 1000);
  if (seconds < 60) return `${seconds}s ago`;
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  return `${Math.floor(seconds / 86400)}d ago`;
}

function duration(seconds) {
  if (seconds < 60) return `${seconds}s`;
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
  return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
}

function escHtml(s) {
  const d = document.createElement('div');
  d.textContent = s || '';
  return d.innerHTML;
}

function escAttr(s) {
  return escHtml(s).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

function badge(text, cls) {
  return `<span class="badge badge-${escAttr(cls)}">${escHtml(text)}</span>`;
}

function runIcon(status, conclusion) {
  if (status === 'in_progress' || status === 'queued' || status === 'pending')
    return '<span class="spinner"></span>';
  if (conclusion === 'success') return '<svg class="run-icon" viewBox="0 0 16 16" fill="#3fb950"><path d="M8 16A8 8 0 108 0a8 8 0 000 16zm3.78-9.72a.75.75 0 00-1.06-1.06L6.75 9.19 5.28 7.72a.75.75 0 00-1.06 1.06l2 2a.75.75 0 001.06 0l4.5-4.5z"/></svg>';
  if (conclusion === 'failure') return '<svg class="run-icon" viewBox="0 0 16 16" fill="#f85149"><path d="M2.343 13.657A8 8 0 1113.657 2.343 8 8 0 012.343 13.657zM6.03 4.97a.75.75 0 00-1.06 1.06L6.94 8 4.97 9.97a.75.75 0 101.06 1.06L8 9.06l1.97 1.97a.75.75 0 101.06-1.06L9.06 8l1.97-1.97a.75.75 0 10-1.06-1.06L8 6.94 6.03 4.97z"/></svg>';
  if (conclusion === 'action_required') return '<svg class="run-icon" viewBox="0 0 16 16" fill="#d29922"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM8 5a.75.75 0 00-.75.75v2.5a.75.75 0 001.5 0v-2.5A.75.75 0 008 5zm1 6a1 1 0 11-2 0 1 1 0 012 0z"/></svg>';
  return '<svg class="run-icon" viewBox="0 0 16 16" fill="#8b949e"><circle cx="8" cy="8" r="6" stroke="#8b949e" stroke-width="1.5" fill="none"/></svg>';
}

// Categorize a PR by its title/labels
function categorize(pr) {
  const t = (pr.title || '').toLowerCase();
  const labels = (pr.labels || []).map(l => l.name);
  if (t.startsWith('fix:') || t.includes('bug') || labels.includes('type: bug'))
    return { tag: 'Bug Fix', cls: 'cat-bugfix' };
  if (t.includes('test') || t.includes('coverage') || labels.includes('type: test'))
    return { tag: 'Tests', cls: 'cat-test' };
  if (t.includes('security') || t.includes('replay') || t.includes('vuln'))
    return { tag: 'Security', cls: 'cat-security' };
  if (t.startsWith('feat:') || t.includes('feature') || labels.includes('type: feature'))
    return { tag: 'Feature', cls: 'cat-feature' };
  if (t.includes('refactor') || t.includes('cleanup'))
    return { tag: 'Refactor', cls: 'cat-refactor' };
  if (t.includes('ci') || t.includes('workflow') || t.includes('pipeline') || t.includes('dashboard'))
    return { tag: 'Infra', cls: 'cat-infra' };
  return { tag: 'Change', cls: 'cat-refactor' };
}

// Describe what a PR actually does based on title and files
function describeImpact(pr, files) {
  const t = pr.title || '';
  // Try to extract a meaningful description from the title
  const cleaned = t
    .replace(/^(impl|spec|fix|feat|test|chore|refactor|security):\s*/i, '')
    .replace(/Issue #\d+\s*[-—]\s*/g, '')
    .replace(/Goose implementation/i, '')
    .trim();

  // Summarize affected packages from file paths
  const pkgs = new Set();
  (files || []).forEach(f => {
    const m = f.filename.match(/^pkg\/(\w+)\//);
    if (m) pkgs.add(`pkg/${m[1]}`);
    else if (f.filename.startsWith('.github/')) pkgs.add('.github');
    else if (f.filename.startsWith('docs/')) pkgs.add('docs');
  });

  return { description: cleaned, packages: [...pkgs] };
}

// ── Data fetching ──
// Rate budget: 60 requests/hr unauthenticated.
// Strategy: ETag conditional requests (If-None-Match → 304 Not Modified).
//   304 responses do NOT count against the rate limit, so repeat fetches
//   of unchanged data are essentially free. Only genuine changes cost a
//   rate limit token. Combined with 5-min intervals and light/full cycle
//   splitting, actual rate consumption is typically 5–15 req/hr.
//   Cache persists to localStorage across page reloads.
let fetchCount = 0;
let cachedData = {};
const REFRESH_MS = 300000; // 5 minutes

async function fetchPipelineSummary() {
  try {
    // Use chimney's own /api/pipeline/summary endpoint — cached 60s server-side.
    const origin = window.location.origin;
    const res = await fetch(`${origin}/api/pipeline/summary`, { cache: 'no-store' });
    if (!res.ok) return;
    const data = await res.json();

    const versionEl = document.getElementById('traction-wgmesh-version');
    if (versionEl) versionEl.textContent = data.wgmesh_version || 'unknown';

    const issuesEl = document.getElementById('traction-open-issues');
    if (issuesEl) issuesEl.textContent = data.open_issues ?? '-';

    const prsEl = document.getElementById('traction-open-prs');
    if (prsEl) prsEl.textContent = data.open_prs ?? '-';

    const rateEl = document.getElementById('traction-goose-rate');
    if (rateEl) {
      if (data.goose_success_rate_pct != null) {
        const pct = Math.round(data.goose_success_rate_pct);
        rateEl.textContent = `${pct}%`;
        rateEl.style.color = pct >= 80 ? 'var(--green)' : pct >= 60 ? 'var(--yellow)' : 'var(--red)';
      }
    }

    const mergeEl = document.getElementById('traction-last-merge');
    if (mergeEl && data.last_merged_pr) {
      const pr = data.last_merged_pr;
      const when = pr.merged_at ? new Date(pr.merged_at).toLocaleDateString() : '';
      mergeEl.innerHTML = `<a href="https://github.com/atvirokodosprendimai/wgmesh/pull/${pr.number}" target="_blank">#${pr.number}</a> ${when}`;
    }
  } catch (e) {
    console.warn('pipeline/summary fetch failed (local dev?):', e.message);
  }
}

async function fetchAll() {
  try {
    fetchCount++;
    const isFull = fetchCount === 1 || fetchCount % 3 === 0; // Full fetch every ~15min

    // Always fetch these (3 calls - added dedicated Goose run fetch)
    const [openPRs, runs, gooseRuns] = await Promise.all([
      ghFetch('/pulls?state=open&per_page=30'),
      ghFetch('/actions/runs?per_page=40'),
      ghFetch('/actions/runs?workflow=goose-build.yml&per_page=10&status=completed'),
    ]);

    let closedPRs, allOpenIssues;
    if (isFull) {
      // Full fetch adds 2 more calls
      [closedPRs, allOpenIssues] = await Promise.all([
        ghFetch('/pulls?state=closed&per_page=20&sort=updated&direction=desc'),
        ghFetch('/issues?state=open&per_page=50'),
      ]);
      cachedData.closedPRs = closedPRs;
      cachedData.allOpenIssues = allOpenIssues;
    } else {
      closedPRs = cachedData.closedPRs || [];
      allOpenIssues = cachedData.allOpenIssues || [];
    }

    const pipelineIssues = allOpenIssues.filter(i =>
      !i.pull_request &&
      (i.labels.some(l => ['copilot-triaging', 'needs-triage'].includes(l.name)) ||
       i.assignees.some(a =>
         a.login === 'Copilot' ||
         a.login === 'copilot-swe-agent[bot]' ||
         a.login.includes('copilot')
       ))
    );

    renderDORA(closedPRs, runs);
    renderPipeline(pipelineIssues, openPRs, closedPRs, runs);
    renderActiveRuns(runs);
    renderRecentRuns(runs);
    if (isFull) {
      renderImpact(closedPRs);
      fetchMem0Stats(gooseRuns);
    }

    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
  } catch (err) {
    console.error('Fetch error:', err);
    document.getElementById('last-update').textContent = `Error: ${err.message}`;
  }
}

function renderDORA(closedPRs, runs) {
  const weekAgo = Date.now() - 7 * 86400000;
  const mergedThisWeek = closedPRs.filter(pr =>
    pr.merged_at && new Date(pr.merged_at).getTime() > weekAgo
  );

  // Lead time: avg time from PR creation to merge
  const leadTimes = mergedThisWeek
    .filter(pr => pr.merged_at)
    .map(pr => (new Date(pr.merged_at) - new Date(pr.created_at)) / 1000);
  const avgLead = leadTimes.length > 0
    ? Math.round(leadTimes.reduce((a, b) => a + b, 0) / leadTimes.length)
    : 0;

  // Active runs
  const activeRuns = runs.workflow_runs.filter(r =>
    r.status === 'in_progress' || r.status === 'queued'
  );

  // Goose success rate
  const gooseRuns = runs.workflow_runs.filter(r =>
    r.name === 'Goose Implementation' &&
    r.status === 'completed' &&
    new Date(r.created_at).getTime() > weekAgo
  );
  const gooseSuccess = gooseRuns.filter(r => r.conclusion === 'success').length;
  const gooseTotal = gooseRuns.length;

  document.getElementById('dora-freq').textContent = mergedThisWeek.length;
  document.getElementById('dora-lead').textContent = avgLead > 0 ? duration(avgLead) : 'N/A';
  // Active runs count — issue count is set by renderPipeline()
  document.getElementById('dora-active').textContent = `${activeRuns.length} active`;
  document.getElementById('dora-success').textContent =
    gooseTotal > 0 ? `${gooseSuccess}/${gooseTotal}` : 'N/A';
}

async function renderImpact(closedPRs) {
  const el = document.getElementById('impact-list');
  const merged = closedPRs.filter(pr => pr.merged_at).slice(0, 8);

  if (merged.length === 0) {
    el.innerHTML = '<div class="empty">No recently merged PRs</div>';
    return;
  }

  // Fetch files for each merged PR (batch — uses N API calls, max 8)
  // Only fetch if we haven't already
  const prFilesCache = window._prFilesCache || {};
  const needsFetch = merged.filter(pr => !prFilesCache[pr.number]);

  // Limit concurrent fetches to conserve rate limit
  for (const pr of needsFetch.slice(0, 4)) {
    try {
      prFilesCache[pr.number] = await ghFetch(`/pulls/${pr.number}/files?per_page=100`);
    } catch {
      prFilesCache[pr.number] = [];
    }
  }
  window._prFilesCache = prFilesCache;

  let totalAdd = 0, totalDel = 0;

  const cards = merged.map(pr => {
    const cat = categorize(pr);
    const files = prFilesCache[pr.number] || [];
    const { description, packages } = describeImpact(pr, files);

    const additions = files.reduce((s, f) => s + (f.additions || 0), 0);
    const deletions = files.reduce((s, f) => s + (f.deletions || 0), 0);
    totalAdd += additions;
    totalDel += deletions;

    // Show actual changed files (Go source only, not specs/docs)
    const goFiles = files.filter(f =>
      f.filename.endsWith('.go') && !f.filename.includes('spec')
    ).slice(0, 5);

    const testFiles = files.filter(f => f.filename.endsWith('_test.go'));
    const srcFiles = files.filter(f => f.filename.endsWith('.go') && !f.filename.endsWith('_test.go'));

    const authorLogin = pr.user?.login || 'unknown';
    const isBot = authorLogin.includes('bot') || authorLogin.includes('copilot') || authorLogin.includes('actions');

    return `<div class="impact-card">
      <div class="impact-title">
        <span class="category-tag ${cat.cls}">${escHtml(cat.tag)}</span>
        <a href="${escAttr(pr.html_url)}">#${pr.number}</a>
        ${escHtml(description || pr.title)}
      </div>
      <div class="impact-meta">
        ${badge(authorLogin, isBot ? 'purple' : 'blue')}
        &middot; merged ${escHtml(timeAgo(pr.merged_at))}
        &middot;
        <span class="impact-stat"><span class="diff-add">+${additions}</span></span>
        <span class="impact-stat"><span class="diff-del">-${deletions}</span></span>
        ${testFiles.length > 0 ? `&middot; <span class="impact-stat">${badge(testFiles.length + ' test file' + (testFiles.length !== 1 ? 's' : ''), 'purple')}</span>` : ''}
        ${srcFiles.length > 0 ? `&middot; <span class="impact-stat">${badge(srcFiles.length + ' source file' + (srcFiles.length !== 1 ? 's' : ''), 'blue')}</span>` : ''}
      </div>
      ${packages.length > 0 ? `<div class="impact-files">Packages: ${packages.map(p => `<span class="impact-file">${escHtml(p)}</span>`).join('')}</div>` : ''}
      ${goFiles.length > 0 ? `<div class="impact-files">Files: ${goFiles.map(f => `<span class="impact-file">${escHtml(f.filename.split('/').pop())}</span>`).join('')}</div>` : ''}
    </div>`;
  });

  el.innerHTML = cards.join('');

  // Update totals in DORA section
  document.getElementById('impact-additions').textContent = `+${totalAdd}`;
  document.getElementById('impact-deletions').textContent = `-${totalDel}`;

  // Render business impact from the same data
  renderBusinessImpact(merged, totalAdd, totalDel);
}

function renderBusinessImpact(mergedPRs, totalAdd, totalDel) {
  // Categorize all merged PRs
  const counts = { bugfix: 0, test: 0, security: 0, feature: 0, infra: 0, refactor: 0 };
  const byCategory = {};
  let totalTestFiles = 0;

  mergedPRs.forEach(pr => {
    const cat = categorize(pr);
    const files = (window._prFilesCache || {})[pr.number] || [];
    const testFiles = files.filter(f => f.filename.endsWith('_test.go'));
    totalTestFiles += testFiles.length;

    const key = cat.tag.toLowerCase().replace(' ', '');
    counts[key] = (counts[key] || 0) + 1;
    if (!byCategory[cat.tag]) byCategory[cat.tag] = [];
    byCategory[cat.tag].push(pr);
  });

  // Lead time (same calc as DORA but we want the value)
  const leadTimes = mergedPRs
    .filter(pr => pr.merged_at)
    .map(pr => (new Date(pr.merged_at) - new Date(pr.created_at)) / 1000);
  const avgLead = leadTimes.length > 0
    ? Math.round(leadTimes.reduce((a, b) => a + b, 0) / leadTimes.length)
    : 0;

  // Reliability metric
  const bugCount = counts.bugfix || 0;
  document.getElementById('biz-reliability').textContent = bugCount;
  document.getElementById('biz-reliability-detail').textContent =
    bugCount === 1 ? 'bug fixed this week' : 'bugs fixed this week';

  // Security metric
  const secCount = counts.security || 0;
  document.getElementById('biz-security').textContent = secCount;
  document.getElementById('biz-security-detail').textContent =
    secCount === 1 ? 'vulnerability addressed' : 'vulnerabilities addressed';

  // Quality metric
  document.getElementById('biz-quality').textContent = totalTestFiles;
  document.getElementById('biz-quality-detail').textContent =
    totalTestFiles === 1 ? 'test file added/modified' : 'test files added/modified';

  // Velocity metric
  document.getElementById('biz-velocity').textContent = avgLead > 0 ? duration(avgLead) : 'N/A';
  document.getElementById('biz-velocity-detail').textContent = 'avg issue to production';

  // Build the narrative — human-readable product impact
  const narrativeEl = document.getElementById('biz-narrative');
  const parts = [];

  if (mergedPRs.length === 0) {
    narrativeEl.innerHTML = '<p style="color:var(--muted)">No merged PRs in the analysis window.</p>';
    return;
  }

  // Opening
  parts.push(`<p>This week, the autonomous pipeline shipped <span class="biz-highlight">${mergedPRs.length} change${mergedPRs.length !== 1 ? 's' : ''}</span> to production — <span class="biz-highlight">+${totalAdd}</span> lines added, <span style="color:var(--red)">${totalDel}</span> removed.</p>`);

  // Reliability story
  if (bugCount > 0) {
    const bugPRs = byCategory['Bug Fix'] || [];
    const bugDescs = bugPRs.map(pr => {
      const d = (pr.title || '')
        .replace(/^(impl|fix|spec):\s*/i, '')
        .replace(/Issue #\d+\s*[-—]\s*/g, '')
        .replace(/Goose implementation/i, '')
        .trim();
      return d;
    }).filter(Boolean).slice(0, 3);
    parts.push(`<p><strong>Reliability:</strong> ${bugCount} bug${bugCount !== 1 ? 's' : ''} fixed — ${bugDescs.length > 0 ? escHtml(bugDescs.join('; ')) + '.' : 'improving system stability.'} Each fix reduces risk of connection drops or resource leaks in production mesh networks.</p>`);
  }

  // Security story
  if (secCount > 0) {
    const secPRs = byCategory['Security'] || [];
    const secDescs = secPRs.map(pr => {
      const d = (pr.title || '')
        .replace(/^(impl|fix|spec|security):\s*/i, '')
        .replace(/Issue #\d+\s*[-—]\s*/g, '')
        .replace(/Goose implementation/i, '')
        .trim();
      return d;
    }).filter(Boolean).slice(0, 3);
    parts.push(`<p><strong>Security posture:</strong> ${secCount} ${secCount !== 1 ? 'vulnerabilities' : 'vulnerability'} addressed — ${secDescs.length > 0 ? escHtml(secDescs.join('; ')) + '.' : 'hardening the mesh protocol.'} These changes directly reduce the attack surface for mesh network operators.</p>`);
  }

  // Quality story
  if (totalTestFiles > 0 || (counts.test || 0) > 0) {
    const testPRs = byCategory['Tests'] || [];
    const covDescs = testPRs.map(pr => {
      const files = (window._prFilesCache || {})[pr.number] || [];
      const pkgs = new Set();
      files.forEach(f => {
        const m = f.filename.match(/^pkg\/(\w+)\//);
        if (m) pkgs.add(m[1]);
      });
      return pkgs.size > 0 ? [...pkgs].join(', ') : null;
    }).filter(Boolean);
    parts.push(`<p><strong>Release confidence:</strong> ${totalTestFiles} test file${totalTestFiles !== 1 ? 's' : ''} added or improved${covDescs.length > 0 ? ` covering <span class="biz-highlight">${escHtml(covDescs.join(', '))}</span>` : ''}. Higher test coverage means safer refactors and fewer regressions reaching users.</p>`);
  }

  // Feature story
  if ((counts.feature || 0) > 0) {
    const featPRs = byCategory['Feature'] || [];
    const featDescs = featPRs.map(pr => {
      const d = (pr.title || '')
        .replace(/^(impl|feat|spec):\s*/i, '')
        .replace(/Issue #\d+\s*[-—]\s*/g, '')
        .replace(/Goose implementation/i, '')
        .trim();
      return d;
    }).filter(Boolean).slice(0, 3);
    parts.push(`<p><strong>New capabilities:</strong> ${featDescs.length > 0 ? escHtml(featDescs.join('; ')) + '.' : `${counts.feature} new feature${counts.feature !== 1 ? 's' : ''} added.`}</p>`);
  }

  // Infra story
  if ((counts.infra || 0) > 0) {
    parts.push(`<p><strong>Developer velocity:</strong> ${counts.infra} pipeline improvement${counts.infra !== 1 ? 's' : ''} shipped — each one reduces the time from idea to production code.</p>`);
  }

  // Pipeline velocity story
  if (avgLead > 0) {
    const leadStr = duration(avgLead);
    const isGood = avgLead < 3600; // under 1h
    parts.push(`<p><strong>Time to market:</strong> Average lead time from PR creation to production is <span class="${isGood ? 'biz-highlight' : 'biz-warn'}">${leadStr}</span>. ${isGood ? 'The autonomous pipeline is delivering changes faster than most human-only teams.' : 'There is room to optimize the review and merge cycle.'}</p>`);
  }

  narrativeEl.innerHTML = parts.join('');
}

function renderPipeline(issues, openPRs, closedPRs, runs) {
  const tbody = document.querySelector('#pipeline-tracker tbody');
  // Update active count in DORA
  const doraActive = document.getElementById('dora-active');
  const activeCount = runs.workflow_runs.filter(r => r.status === 'in_progress' || r.status === 'queued').length;
  doraActive.textContent = `${activeCount} / ${issues.length}`;

  if (issues.length === 0) {
    tbody.innerHTML = '<tr><td colspan="8" class="empty">No active pipeline issues</td></tr>';
    return;
  }

  const allPRs = [...openPRs, ...closedPRs];
  const allRuns = runs.workflow_runs;

  const rows = issues.map(issue => {
    const num = issue.number;
    const cat = categorize(issue);
    const isCopilotTriaging = issue.labels.some(l => l.name === 'copilot-triaging');

    // Find spec PR (title contains issue number)
    const specPR = allPRs.find(pr =>
      pr.title.includes(`Issue #${num}`) && pr.title.startsWith('spec:')
    );

    // Find impl PR (created by goose/github-actions, references issue)
    const implPR = allPRs.find(pr =>
      !pr.title.startsWith('spec:') &&
      (pr.title.includes(`#${num}`) || (pr.body || '').includes(`#${num}`)) &&
      pr.user.login !== 'copilot-swe-agent[bot]'
    );

    // Find Goose runs for this issue
    const gooseRuns = allRuns.filter(r =>
      r.name === 'Goose Implementation' &&
      (r.head_branch?.includes(specPR?.head?.ref || `issue-${num}`) ||
       (r.display_title || '').includes(`#${num}`))
    );
    const gooseActive = gooseRuns.some(r => r.status === 'in_progress' || r.status === 'queued');
    const gooseDone = gooseRuns.some(r => r.conclusion === 'success');
    const gooseFailed = gooseRuns.some(r => r.conclusion === 'failure') && !gooseDone;

    // Stages
    const triaged = isCopilotTriaging || !!specPR;
    const merged = !!implPR?.merged_at;

    // Age
    const age = timeAgo(issue.created_at);

    // Spec status
    let specBadge;
    if (!specPR) specBadge = badge('Pending', 'muted');
    else if (specPR.merged_at) specBadge = badge('Merged', 'green');
    else if (specPR.state === 'open') specBadge = `<a href="${escAttr(specPR.html_url)}">${badge('#' + specPR.number + ' Open', 'blue')}</a>`;
    else specBadge = badge('Closed', 'red');

    // Goose status
    let gooseBadge;
    if (gooseActive) gooseBadge = `<span style="display:flex;align-items:center;gap:0.25rem"><span class="spinner"></span> Building</span>`;
    else if (gooseDone) gooseBadge = badge('Success', 'green');
    else if (gooseFailed) gooseBadge = badge('Failed', 'red');
    else if (specPR) gooseBadge = badge('Queued', 'yellow');
    else gooseBadge = badge('Waiting', 'muted');

    // Impl PR
    let implBadge;
    if (!implPR) implBadge = gooseActive ? badge('Building...', 'yellow') : badge('-', 'muted');
    else if (implPR.merged_at) implBadge = `<a href="${escAttr(implPR.html_url)}">${badge('#' + implPR.number + ' Merged', 'green')}</a>`;
    else implBadge = `<a href="${escAttr(implPR.html_url)}">${badge('#' + implPR.number + ' Open', 'blue')}</a>`;

    const mergedBadge = merged ? badge('Done', 'green') : badge('-', 'muted');

    return `<tr>
      <td><a href="${escAttr(issue.html_url)}">#${num}</a> ${escHtml((issue.title || '').substring(0, 60))}</td>
      <td><span class="category-tag ${cat.cls}">${escHtml(cat.tag)}</span></td>
      <td>${triaged ? badge('Done', 'green') : badge('Pending', 'yellow')}</td>
      <td>${specBadge}</td>
      <td>${gooseBadge}</td>
      <td>${implBadge}</td>
      <td>${mergedBadge}</td>
      <td style="color:var(--muted)">${escHtml(age)}</td>
    </tr>`;
  });

  tbody.innerHTML = rows.join('');
}

function renderActiveRuns(runs) {
  const el = document.getElementById('active-runs');
  const active = runs.workflow_runs.filter(r =>
    r.status === 'in_progress' || r.status === 'queued' || r.status === 'pending'
  ).slice(0, 12);

  if (active.length === 0) {
    el.innerHTML = '<li class="empty">No active runs</li>';
    return;
  }

  el.innerHTML = active.map(r => `
    <li class="run-item">
      ${runIcon(r.status, r.conclusion)}
      <a href="${escAttr(r.html_url)}" style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"
        title="${escAttr(r.display_title || r.name)}">${escHtml(r.name)}</a>
      <span style="color:var(--muted);font-size:0.75rem;white-space:nowrap">${escHtml(timeAgo(r.created_at))}</span>
    </li>
  `).join('');
}

function renderRecentRuns(runs) {
  const el = document.getElementById('recent-runs');
  const recent = runs.workflow_runs.filter(r =>
    r.status === 'completed' &&
    ['Goose Implementation', 'Spec Auto-Approve', 'Auto-merge on CI pass', 'Copilot Issue Triage'].includes(r.name)
  ).slice(0, 10);

  if (recent.length === 0) {
    el.innerHTML = '<li class="empty">No recent runs</li>';
    return;
  }

  el.innerHTML = recent.map(r => `
    <li class="run-item">
      ${runIcon(r.status, r.conclusion)}
      <a href="${escAttr(r.html_url)}" style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"
        title="${escAttr(r.display_title || r.name)}">${escHtml(r.name)}</a>
      <span style="color:var(--muted);font-size:0.75rem;white-space:nowrap">${escHtml(timeAgo(r.updated_at))}</span>
    </li>
  `).join('');
}

// ── mem0 Statistics ──
// Parses Goose Implementation run job logs to extract mem0 retrieve/save stats.
// Uses the Jobs API: /actions/runs/{id}/jobs — 1 API call per run.
// We only parse the 3 most recent completed Goose runs, and cache results.

const mem0Cache = {};

async function fetchMem0Stats(runs) {
  const gooseRuns = runs.workflow_runs.filter(r =>
    r.name === 'Goose Implementation' && r.status === 'completed'
  ).slice(0, 5);

  if (gooseRuns.length === 0) {
    renderMem0Empty();
    return;
  }

  // Fetch jobs for runs we haven't cached yet (max 5 new fetches per cycle)
  let fetched = 0;
  for (const run of gooseRuns) {
    if (mem0Cache[run.id] || fetched >= 5) continue;
    try {
      const jobsData = await ghFetch(`/actions/runs/${run.id}/jobs`);
      const jobs = jobsData.jobs || [];
      const job = jobs.find(j =>
        Array.isArray(j.steps) &&
        j.steps.some(s =>
          s.name && (
            s.name.includes('Retrieve memories') ||
            s.name.includes('Save memories') ||
            s.name.includes('Encrypt mem0') ||
            s.name.includes('Save mem0 memory cache') ||
            s.name.includes('Restore mem0 memory cache')
          )
        )
      ) || jobs[0];
      if (!job) continue;

      // Extract mem0 stats from step names and conclusions
      const steps = job.steps || [];
      const retrieveStep = steps.find(s => s.name && s.name.includes('Retrieve memories'));
      const saveStep = steps.find(s => s.name && s.name.includes('Save memories'));
      const encryptStep = steps.find(s => s.name && s.name.includes('Encrypt mem0'));
      const cacheStep = steps.find(s => s.name && s.name.includes('Save mem0 memory cache'));
      const restoreStep = steps.find(s => s.name && s.name.includes('Restore mem0 memory cache'));

      mem0Cache[run.id] = {
        runId: run.id,
        runUrl: run.html_url,
        conclusion: run.conclusion,
        createdAt: run.created_at,
        issueTitle: run.display_title || '',
        retrieve: {
          status: retrieveStep?.conclusion || 'skipped',
          ran: !!retrieveStep,
        },
        save: {
          status: saveStep?.conclusion || 'skipped',
          ran: !!saveStep,
        },
        encrypt: {
          status: encryptStep?.conclusion || 'skipped',
          ran: !!encryptStep,
        },
        cacheRestore: restoreStep?.conclusion || 'skipped',
        cacheSave: cacheStep?.conclusion || 'skipped',
      };
      fetched++;
    } catch {
      // Rate limit or other error — skip
    }
  }

  renderMem0(gooseRuns);
}

function renderMem0Empty() {
  document.getElementById('mem0-status').innerHTML = badge('No Data', 'muted');
  document.getElementById('mem0-retrieved').textContent = '-';
  document.getElementById('mem0-saved').textContent = '-';
  document.getElementById('mem0-cache').innerHTML = badge('Unknown', 'muted');
  document.getElementById('mem0-history').innerHTML = '<li class="empty">No Goose runs found</li>';
}

function renderMem0(gooseRuns) {
  const entries = gooseRuns.map(r => mem0Cache[r.id]).filter(Boolean);

  if (entries.length === 0) {
    renderMem0Empty();
    return;
  }

  const latest = entries[0];

  // Status: check if retrieve and save both succeeded
  const retrieveOk = latest.retrieve.ran && latest.retrieve.status === 'success';
  const saveOk = latest.save.ran && latest.save.status === 'success';
  const encryptOk = latest.encrypt.ran && latest.encrypt.status === 'success';

  let statusBadge;
  if (retrieveOk && saveOk) {
    statusBadge = badge('Healthy', 'green');
  } else if (latest.retrieve.ran || latest.save.ran) {
    // Steps ran but may have had issues (the BaseLlmConfig bug)
    statusBadge = badge('Degraded', 'yellow');
  } else {
    statusBadge = badge('Disabled', 'muted');
  }
  document.getElementById('mem0-status').innerHTML = statusBadge;

  // Retrieve/save — we can't get exact counts without log parsing,
  // but we can show step success/failure
  document.getElementById('mem0-retrieved').innerHTML =
    latest.retrieve.ran
      ? (retrieveOk ? badge('OK', 'green') : badge('Failed', 'red'))
      : badge('Skipped', 'muted');

  document.getElementById('mem0-saved').innerHTML =
    latest.save.ran
      ? (saveOk ? badge('OK', 'green') : badge('Failed', 'red'))
      : badge('Skipped', 'muted');

  // Cache status
  document.getElementById('mem0-cache').innerHTML =
    encryptOk
      ? badge('Encrypted + Cached', 'green')
      : latest.cacheSave === 'success'
        ? badge('Cached (unencrypted)', 'yellow')
        : badge('Not cached', 'red');

  // History list
  const historyEl = document.getElementById('mem0-history');
  historyEl.innerHTML = entries.map(e => {
    const retrieveBadge = e.retrieve.ran
      ? (e.retrieve.status === 'success' ? badge('Retrieved', 'green') : badge('Retrieve failed', 'red'))
      : badge('No retrieve', 'muted');
    const saveBadge = e.save.ran
      ? (e.save.status === 'success' ? badge('Saved', 'green') : badge('Save failed', 'red'))
      : badge('No save', 'muted');

    return `<li class="run-item">
      ${runIcon('completed', e.conclusion)}
      <a href="${escAttr(e.runUrl)}" style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"
        title="${escAttr(e.issueTitle)}">${escHtml(e.issueTitle.substring(0, 40))}</a>
      ${retrieveBadge} ${saveBadge}
      <span style="color:var(--muted);font-size:0.75rem;white-space:nowrap">${escHtml(timeAgo(e.createdAt))}</span>
    </li>`;
  }).join('');
}

// ── Init ──
fetchAll();
fetchPipelineSummary(); // chimney-native endpoint — no GitHub rate limit cost
setInterval(fetchAll, REFRESH_MS); // 5 min — reduces API call volume to stay within unauthenticated rate limits
setInterval(fetchPipelineSummary, 60000); // refresh pipeline summary every 60s (server-side cached)
</script>
</body>
</html>
