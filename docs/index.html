<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>wgmesh — Agent Pipeline Dashboard</title>
<style>
:root {
  --bg: #0d1117; --surface: #161b22; --border: #30363d;
  --text: #e6edf3; --muted: #8b949e; --accent: #58a6ff;
  --green: #3fb950; --red: #f85149; --yellow: #d29922; --purple: #bc8cff;
  --orange: #f0883e;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  background: var(--bg); color: var(--text); line-height: 1.5; padding: 1rem; }
a { color: var(--accent); text-decoration: none; }
a:hover { text-decoration: underline; }

.header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
.header h1 { font-size: 1.5rem; font-weight: 600; }
.header .subtitle { color: var(--muted); font-size: 0.875rem; }
.refresh-info { margin-left: auto; color: var(--muted); font-size: 0.75rem; }
.rate-info { color: var(--muted); font-size: 0.6875rem; }

.grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
.card { background: var(--surface); border: 1px solid var(--border); border-radius: 6px; padding: 1rem; }
.card h2 { font-size: 0.875rem; font-weight: 600; color: var(--muted); text-transform: uppercase;
  letter-spacing: 0.05em; margin-bottom: 0.75rem; }

.stat-row { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 0.5rem; }
.stat-label { color: var(--muted); font-size: 0.8125rem; }
.stat-value { font-size: 1.25rem; font-weight: 600; font-variant-numeric: tabular-nums; }
.stat-value.green { color: var(--green); }
.stat-value.red { color: var(--red); }
.stat-value.yellow { color: var(--yellow); }
.stat-value.purple { color: var(--purple); }
.stat-value.accent { color: var(--accent); }

.pipeline-table { width: 100%; border-collapse: collapse; font-size: 0.8125rem; }
.pipeline-table th { text-align: left; color: var(--muted); font-weight: 500;
  padding: 0.5rem 0.75rem; border-bottom: 1px solid var(--border); }
.pipeline-table td { padding: 0.5rem 0.75rem; border-bottom: 1px solid var(--border); vertical-align: top; }
.pipeline-table tr:last-child td { border-bottom: none; }

.badge { display: inline-block; padding: 0.125rem 0.5rem; border-radius: 999px;
  font-size: 0.6875rem; font-weight: 600; white-space: nowrap; }
.badge-green { background: rgba(63,185,80,0.15); color: var(--green); }
.badge-red { background: rgba(248,81,73,0.15); color: var(--red); }
.badge-yellow { background: rgba(210,153,34,0.15); color: var(--yellow); }
.badge-purple { background: rgba(188,140,255,0.15); color: var(--purple); }
.badge-blue { background: rgba(88,166,255,0.15); color: var(--accent); }
.badge-muted { background: rgba(139,148,158,0.15); color: var(--muted); }
.badge-orange { background: rgba(240,136,62,0.15); color: var(--orange); }

.run-list { list-style: none; }
.run-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.375rem 0;
  border-bottom: 1px solid var(--border); font-size: 0.8125rem; }
.run-item:last-child { border-bottom: none; }
.run-icon { width: 16px; height: 16px; flex-shrink: 0; }

.spinner { display: inline-block; width: 14px; height: 14px; border: 2px solid var(--border);
  border-top-color: var(--yellow); border-radius: 50%; animation: spin 0.8s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }

/* Impact cards */
.impact-card { background: var(--surface); border: 1px solid var(--border); border-radius: 6px;
  padding: 1rem; margin-bottom: 0.75rem; }
.impact-title { font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem; }
.impact-meta { font-size: 0.75rem; color: var(--muted); margin-bottom: 0.5rem; }
.impact-files { font-size: 0.75rem; margin-top: 0.5rem; }
.impact-file { display: inline-block; padding: 0.125rem 0.375rem; border-radius: 3px;
  background: rgba(88,166,255,0.1); color: var(--accent); margin: 0.125rem; font-family: monospace; }
.impact-stat { display: inline-flex; align-items: center; gap: 0.25rem; font-size: 0.75rem;
  margin-right: 0.75rem; }
.diff-add { color: var(--green); }
.diff-del { color: var(--red); }

.empty { color: var(--muted); font-style: italic; padding: 1rem 0; text-align: center; }
.loading { text-align: center; padding: 2rem; color: var(--muted); }

.full-width { grid-column: 1 / -1; }
.overflow-x { overflow-x: auto; }

.category-tag { display: inline-block; padding: 0.125rem 0.375rem; border-radius: 3px;
  font-size: 0.6875rem; font-weight: 600; margin-right: 0.25rem; }
.cat-bugfix { background: rgba(248,81,73,0.15); color: var(--red); }
.cat-test { background: rgba(188,140,255,0.15); color: var(--purple); }
.cat-security { background: rgba(240,136,62,0.15); color: var(--orange); }
.cat-feature { background: rgba(63,185,80,0.15); color: var(--green); }
.cat-infra { background: rgba(88,166,255,0.15); color: var(--accent); }
.cat-refactor { background: rgba(210,153,34,0.15); color: var(--yellow); }

footer { text-align: center; color: var(--muted); font-size: 0.75rem; padding: 2rem 0 1rem; }
</style>
</head>
<body>

<div class="header">
  <h1>wgmesh Agent Pipeline</h1>
  <span class="subtitle">Autonomous AI coding pipeline — issue to merge</span>
  <div style="margin-left:auto;text-align:right">
    <span class="refresh-info">Auto-refreshes every 2m &middot; <span id="last-update">loading...</span></span>
    <div class="rate-info">GitHub API: <span id="rate-remaining">?</span>/60 requests remaining</div>
  </div>
</div>

<!-- DORA metrics row -->
<div class="grid" id="dora-section">
  <div class="card">
    <h2>Deployment Frequency</h2>
    <div class="stat-row">
      <span class="stat-label">Merged PRs (7d)</span>
      <span class="stat-value green" id="dora-freq">-</span>
    </div>
  </div>
  <div class="card">
    <h2>Lead Time</h2>
    <div class="stat-row">
      <span class="stat-label">Avg PR open &rarr; merge</span>
      <span class="stat-value accent" id="dora-lead">-</span>
    </div>
  </div>
  <div class="card">
    <h2>Code Impact (7d)</h2>
    <div class="stat-row">
      <span class="stat-label">Lines added</span>
      <span class="stat-value green" id="impact-additions">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Lines removed</span>
      <span class="stat-value red" id="impact-deletions">-</span>
    </div>
  </div>
  <div class="card">
    <h2>Goose Success Rate</h2>
    <div class="stat-row">
      <span class="stat-label">Builds (7d)</span>
      <span class="stat-value green" id="dora-success">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Active / Open issues</span>
      <span class="stat-value yellow" id="dora-active">-</span>
    </div>
  </div>
</div>

<!-- mem0 Memory System -->
<div class="grid">
  <div class="card">
    <h2>mem0 Agent Memory</h2>
    <div class="stat-row">
      <span class="stat-label">Status</span>
      <span class="stat-value" id="mem0-status" style="font-size:0.875rem">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Memories retrieved (last run)</span>
      <span class="stat-value accent" id="mem0-retrieved">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Memories saved (last run)</span>
      <span class="stat-value green" id="mem0-saved">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Cache</span>
      <span class="stat-value" id="mem0-cache" style="font-size:0.875rem">-</span>
    </div>
  </div>
  <div class="card">
    <h2>mem0 Run History</h2>
    <div style="font-size:0.8125rem;color:var(--muted);margin-bottom:0.5rem">
      Memory retrieval/save results from recent Goose builds
    </div>
    <ul class="run-list" id="mem0-history">
      <li class="loading">Loading...</li>
    </ul>
  </div>
</div>

<!-- What was actually built — the main event -->
<div class="grid">
  <div class="card full-width">
    <h2>What the Pipeline Built — Recent Merged Changes</h2>
    <div id="impact-list">
      <div class="loading">Loading merged PR details...</div>
    </div>
  </div>
</div>

<!-- Active pipeline items -->
<div class="grid">
  <div class="card full-width">
    <h2>Pipeline Tracker — Active Issues</h2>
    <div class="overflow-x">
      <table class="pipeline-table" id="pipeline-tracker">
        <thead>
          <tr>
            <th>Issue</th>
            <th>Type</th>
            <th>Triage</th>
            <th>Spec PR</th>
            <th>Goose Build</th>
            <th>Impl PR</th>
            <th>Merged</th>
            <th>Age</th>
          </tr>
        </thead>
        <tbody>
          <tr><td colspan="8" class="loading">Loading pipeline data...</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Live workflow runs -->
<div class="grid">
  <div class="card">
    <h2>Active Workflow Runs</h2>
    <ul class="run-list" id="active-runs">
      <li class="loading">Loading...</li>
    </ul>
  </div>
  <div class="card">
    <h2>Recent Completions</h2>
    <ul class="run-list" id="recent-runs">
      <li class="loading">Loading...</li>
    </ul>
  </div>
</div>

<footer>
  wgmesh Agent Pipeline Dashboard &middot;
  <a href="https://github.com/atvirokodosprendimai/wgmesh">Repository</a> &middot;
  Data from GitHub REST API (unauthenticated, 60 req/hr)
</footer>

<script>
const OWNER = 'atvirokodosprendimai';
const REPO = 'wgmesh';
const API = `https://api.github.com/repos/${OWNER}/${REPO}`;

let rateLimitRemaining = null;

// Fetch with cache-busting and rate limit tracking
async function ghFetch(path) {
  const url = `${API}${path}`;
  const res = await fetch(url, {
    headers: { 'Accept': 'application/vnd.github+json' },
    cache: 'no-store'
  });
  // Track rate limit
  const remaining = res.headers.get('x-ratelimit-remaining');
  if (remaining !== null) {
    rateLimitRemaining = parseInt(remaining, 10);
    const el = document.getElementById('rate-remaining');
    if (el) el.textContent = rateLimitRemaining;
  }
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return res.json();
}

function timeAgo(dateStr) {
  const seconds = Math.floor((Date.now() - new Date(dateStr).getTime()) / 1000);
  if (seconds < 60) return `${seconds}s ago`;
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  return `${Math.floor(seconds / 86400)}d ago`;
}

function duration(seconds) {
  if (seconds < 60) return `${seconds}s`;
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
  return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
}

function escHtml(s) {
  const d = document.createElement('div');
  d.textContent = s || '';
  return d.innerHTML;
}

function escAttr(s) {
  return escHtml(s).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

function badge(text, cls) {
  return `<span class="badge badge-${escAttr(cls)}">${escHtml(text)}</span>`;
}

function runIcon(status, conclusion) {
  if (status === 'in_progress' || status === 'queued' || status === 'pending')
    return '<span class="spinner"></span>';
  if (conclusion === 'success') return '<svg class="run-icon" viewBox="0 0 16 16" fill="#3fb950"><path d="M8 16A8 8 0 108 0a8 8 0 000 16zm3.78-9.72a.75.75 0 00-1.06-1.06L6.75 9.19 5.28 7.72a.75.75 0 00-1.06 1.06l2 2a.75.75 0 001.06 0l4.5-4.5z"/></svg>';
  if (conclusion === 'failure') return '<svg class="run-icon" viewBox="0 0 16 16" fill="#f85149"><path d="M2.343 13.657A8 8 0 1113.657 2.343 8 8 0 012.343 13.657zM6.03 4.97a.75.75 0 00-1.06 1.06L6.94 8 4.97 9.97a.75.75 0 101.06 1.06L8 9.06l1.97 1.97a.75.75 0 101.06-1.06L9.06 8l1.97-1.97a.75.75 0 10-1.06-1.06L8 6.94 6.03 4.97z"/></svg>';
  if (conclusion === 'action_required') return '<svg class="run-icon" viewBox="0 0 16 16" fill="#d29922"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM8 5a.75.75 0 00-.75.75v2.5a.75.75 0 001.5 0v-2.5A.75.75 0 008 5zm1 6a1 1 0 11-2 0 1 1 0 012 0z"/></svg>';
  return '<svg class="run-icon" viewBox="0 0 16 16" fill="#8b949e"><circle cx="8" cy="8" r="6" stroke="#8b949e" stroke-width="1.5" fill="none"/></svg>';
}

// Categorize a PR by its title/labels
function categorize(pr) {
  const t = (pr.title || '').toLowerCase();
  const labels = (pr.labels || []).map(l => l.name);
  if (t.startsWith('fix:') || t.includes('bug') || labels.includes('type: bug'))
    return { tag: 'Bug Fix', cls: 'cat-bugfix' };
  if (t.includes('test') || t.includes('coverage') || labels.includes('type: test'))
    return { tag: 'Tests', cls: 'cat-test' };
  if (t.includes('security') || t.includes('replay') || t.includes('vuln'))
    return { tag: 'Security', cls: 'cat-security' };
  if (t.startsWith('feat:') || t.includes('feature') || labels.includes('type: feature'))
    return { tag: 'Feature', cls: 'cat-feature' };
  if (t.includes('refactor') || t.includes('cleanup'))
    return { tag: 'Refactor', cls: 'cat-refactor' };
  if (t.includes('ci') || t.includes('workflow') || t.includes('pipeline') || t.includes('dashboard'))
    return { tag: 'Infra', cls: 'cat-infra' };
  return { tag: 'Change', cls: 'cat-refactor' };
}

// Describe what a PR actually does based on title and files
function describeImpact(pr, files) {
  const t = pr.title || '';
  // Try to extract a meaningful description from the title
  const cleaned = t
    .replace(/^(impl|spec|fix|feat|test|chore|refactor|security):\s*/i, '')
    .replace(/Issue #\d+\s*[-—]\s*/g, '')
    .replace(/Goose implementation/i, '')
    .trim();

  // Summarize affected packages from file paths
  const pkgs = new Set();
  (files || []).forEach(f => {
    const m = f.filename.match(/^pkg\/(\w+)\//);
    if (m) pkgs.add(`pkg/${m[1]}`);
    else if (f.filename.startsWith('.github/')) pkgs.add('.github');
    else if (f.filename.startsWith('docs/')) pkgs.add('docs');
  });

  return { description: cleaned, packages: [...pkgs] };
}

// ── Data fetching ──
// Uses 4 API calls per cycle (well within 60/hr at 2min intervals = 30 cycles × 4 = 120... still too many)
// Reduce to essentials: openPRs, closedPRs, runs, issues — 4 calls
// At 2min interval: 30 calls/hr × 4 = ~120. Still over budget.
// Solution: stagger — full fetch every 2 min but only runs/PRs, full details every 5 min
let fetchCount = 0;
let cachedData = {};

async function fetchAll() {
  try {
    fetchCount++;
    const isFull = fetchCount === 1 || fetchCount % 3 === 0; // Full fetch every ~6min

    // Always fetch these (2 calls)
    const [openPRs, runs] = await Promise.all([
      ghFetch('/pulls?state=open&per_page=30'),
      ghFetch('/actions/runs?per_page=40'),
    ]);

    let closedPRs, allOpenIssues;
    if (isFull) {
      // Full fetch adds 2 more calls
      [closedPRs, allOpenIssues] = await Promise.all([
        ghFetch('/pulls?state=closed&per_page=20&sort=updated&direction=desc'),
        ghFetch('/issues?state=open&per_page=50'),
      ]);
      cachedData.closedPRs = closedPRs;
      cachedData.allOpenIssues = allOpenIssues;
    } else {
      closedPRs = cachedData.closedPRs || [];
      allOpenIssues = cachedData.allOpenIssues || [];
    }

    const pipelineIssues = allOpenIssues.filter(i =>
      !i.pull_request &&
      (i.labels.some(l => ['copilot-triaging', 'needs-triage'].includes(l.name)) ||
       i.assignees.some(a =>
         a.login === 'Copilot' ||
         a.login === 'copilot-swe-agent[bot]' ||
         a.login.includes('copilot')
       ))
    );

    renderDORA(closedPRs, runs);
    renderPipeline(pipelineIssues, openPRs, closedPRs, runs);
    renderActiveRuns(runs);
    renderRecentRuns(runs);
    if (isFull) {
      renderImpact(closedPRs);
      fetchMem0Stats(runs);
    }

    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
  } catch (err) {
    console.error('Fetch error:', err);
    document.getElementById('last-update').textContent = `Error: ${err.message}`;
  }
}

function renderDORA(closedPRs, runs) {
  const weekAgo = Date.now() - 7 * 86400000;
  const mergedThisWeek = closedPRs.filter(pr =>
    pr.merged_at && new Date(pr.merged_at).getTime() > weekAgo
  );

  // Lead time: avg time from PR creation to merge
  const leadTimes = mergedThisWeek
    .filter(pr => pr.merged_at)
    .map(pr => (new Date(pr.merged_at) - new Date(pr.created_at)) / 1000);
  const avgLead = leadTimes.length > 0
    ? Math.round(leadTimes.reduce((a, b) => a + b, 0) / leadTimes.length)
    : 0;

  // Active runs
  const activeRuns = runs.workflow_runs.filter(r =>
    r.status === 'in_progress' || r.status === 'queued'
  );

  // Goose success rate
  const gooseRuns = runs.workflow_runs.filter(r =>
    r.name === 'Goose Implementation' &&
    r.status === 'completed' &&
    new Date(r.created_at).getTime() > weekAgo
  );
  const gooseSuccess = gooseRuns.filter(r => r.conclusion === 'success').length;
  const gooseTotal = gooseRuns.length;

  document.getElementById('dora-freq').textContent = mergedThisWeek.length;
  document.getElementById('dora-lead').textContent = avgLead > 0 ? duration(avgLead) : 'N/A';
  document.getElementById('dora-active').textContent = `${activeRuns.length} / ${
    document.getElementById('dora-active').textContent.split('/').pop()?.trim() || '?'
  }`;
  document.getElementById('dora-success').textContent =
    gooseTotal > 0 ? `${gooseSuccess}/${gooseTotal}` : 'N/A';
}

async function renderImpact(closedPRs) {
  const el = document.getElementById('impact-list');
  const merged = closedPRs.filter(pr => pr.merged_at).slice(0, 8);

  if (merged.length === 0) {
    el.innerHTML = '<div class="empty">No recently merged PRs</div>';
    return;
  }

  // Fetch files for each merged PR (batch — uses N API calls, max 8)
  // Only fetch if we haven't already
  const prFilesCache = window._prFilesCache || {};
  const needsFetch = merged.filter(pr => !prFilesCache[pr.number]);

  // Limit concurrent fetches to conserve rate limit
  for (const pr of needsFetch.slice(0, 4)) {
    try {
      prFilesCache[pr.number] = await ghFetch(`/pulls/${pr.number}/files?per_page=30`);
    } catch {
      prFilesCache[pr.number] = [];
    }
  }
  window._prFilesCache = prFilesCache;

  let totalAdd = 0, totalDel = 0;

  const cards = merged.map(pr => {
    const cat = categorize(pr);
    const files = prFilesCache[pr.number] || [];
    const { description, packages } = describeImpact(pr, files);

    const additions = files.reduce((s, f) => s + (f.additions || 0), 0);
    const deletions = files.reduce((s, f) => s + (f.deletions || 0), 0);
    totalAdd += additions;
    totalDel += deletions;

    // Show actual changed files (Go source only, not specs/docs)
    const goFiles = files.filter(f =>
      f.filename.endsWith('.go') && !f.filename.includes('spec')
    ).slice(0, 5);

    const testFiles = files.filter(f => f.filename.endsWith('_test.go'));
    const srcFiles = files.filter(f => f.filename.endsWith('.go') && !f.filename.endsWith('_test.go'));

    const authorLogin = pr.user?.login || 'unknown';
    const isBot = authorLogin.includes('bot') || authorLogin.includes('copilot') || authorLogin.includes('actions');

    return `<div class="impact-card">
      <div class="impact-title">
        <span class="category-tag ${cat.cls}">${escHtml(cat.tag)}</span>
        <a href="${escAttr(pr.html_url)}">#${pr.number}</a>
        ${escHtml(description || pr.title)}
      </div>
      <div class="impact-meta">
        ${badge(authorLogin, isBot ? 'purple' : 'blue')}
        &middot; merged ${escHtml(timeAgo(pr.merged_at))}
        &middot;
        <span class="impact-stat"><span class="diff-add">+${additions}</span></span>
        <span class="impact-stat"><span class="diff-del">-${deletions}</span></span>
        ${testFiles.length > 0 ? `&middot; <span class="impact-stat">${badge(testFiles.length + ' test file' + (testFiles.length !== 1 ? 's' : ''), 'purple')}</span>` : ''}
        ${srcFiles.length > 0 ? `&middot; <span class="impact-stat">${badge(srcFiles.length + ' source file' + (srcFiles.length !== 1 ? 's' : ''), 'blue')}</span>` : ''}
      </div>
      ${packages.length > 0 ? `<div class="impact-files">Packages: ${packages.map(p => `<span class="impact-file">${escHtml(p)}</span>`).join('')}</div>` : ''}
      ${goFiles.length > 0 ? `<div class="impact-files">Files: ${goFiles.map(f => `<span class="impact-file">${escHtml(f.filename.split('/').pop())}</span>`).join('')}</div>` : ''}
    </div>`;
  });

  el.innerHTML = cards.join('');

  // Update totals in DORA section
  document.getElementById('impact-additions').textContent = `+${totalAdd}`;
  document.getElementById('impact-deletions').textContent = `-${totalDel}`;
}

function renderPipeline(issues, openPRs, closedPRs, runs) {
  const tbody = document.querySelector('#pipeline-tracker tbody');
  // Update active count in DORA
  const doraActive = document.getElementById('dora-active');
  const activeCount = runs.workflow_runs.filter(r => r.status === 'in_progress' || r.status === 'queued').length;
  doraActive.textContent = `${activeCount} / ${issues.length}`;

  if (issues.length === 0) {
    tbody.innerHTML = '<tr><td colspan="8" class="empty">No active pipeline issues</td></tr>';
    return;
  }

  const allPRs = [...openPRs, ...closedPRs];
  const allRuns = runs.workflow_runs;

  const rows = issues.map(issue => {
    const num = issue.number;
    const cat = categorize(issue);
    const isCopilotTriaging = issue.labels.some(l => l.name === 'copilot-triaging');

    // Find spec PR (title contains issue number)
    const specPR = allPRs.find(pr =>
      pr.title.includes(`Issue #${num}`) && pr.title.startsWith('spec:')
    );

    // Find impl PR (created by goose/github-actions, references issue)
    const implPR = allPRs.find(pr =>
      !pr.title.startsWith('spec:') &&
      (pr.title.includes(`#${num}`) || (pr.body || '').includes(`#${num}`)) &&
      pr.user.login !== 'copilot-swe-agent[bot]'
    );

    // Find Goose runs for this issue
    const gooseRuns = allRuns.filter(r =>
      r.name === 'Goose Implementation' &&
      (r.head_branch?.includes(specPR?.head?.ref || `issue-${num}`) ||
       (r.display_title || '').includes(`#${num}`))
    );
    const gooseActive = gooseRuns.some(r => r.status === 'in_progress' || r.status === 'queued');
    const gooseDone = gooseRuns.some(r => r.conclusion === 'success');
    const gooseFailed = gooseRuns.some(r => r.conclusion === 'failure') && !gooseDone;

    // Stages
    const triaged = isCopilotTriaging || !!specPR;
    const merged = !!implPR?.merged_at;

    // Age
    const age = timeAgo(issue.created_at);

    // Spec status
    let specBadge;
    if (!specPR) specBadge = badge('Pending', 'muted');
    else if (specPR.merged_at) specBadge = badge('Merged', 'green');
    else if (specPR.state === 'open') specBadge = `<a href="${escAttr(specPR.html_url)}">${badge('#' + specPR.number + ' Open', 'blue')}</a>`;
    else specBadge = badge('Closed', 'red');

    // Goose status
    let gooseBadge;
    if (gooseActive) gooseBadge = `<span style="display:flex;align-items:center;gap:0.25rem"><span class="spinner"></span> Building</span>`;
    else if (gooseDone) gooseBadge = badge('Success', 'green');
    else if (gooseFailed) gooseBadge = badge('Failed', 'red');
    else if (specPR) gooseBadge = badge('Queued', 'yellow');
    else gooseBadge = badge('Waiting', 'muted');

    // Impl PR
    let implBadge;
    if (!implPR) implBadge = gooseActive ? badge('Building...', 'yellow') : badge('-', 'muted');
    else if (implPR.merged_at) implBadge = `<a href="${escAttr(implPR.html_url)}">${badge('#' + implPR.number + ' Merged', 'green')}</a>`;
    else implBadge = `<a href="${escAttr(implPR.html_url)}">${badge('#' + implPR.number + ' Open', 'blue')}</a>`;

    const mergedBadge = merged ? badge('Done', 'green') : badge('-', 'muted');

    return `<tr>
      <td><a href="${escAttr(issue.html_url)}">#${num}</a> ${escHtml((issue.title || '').substring(0, 60))}</td>
      <td><span class="category-tag ${cat.cls}">${escHtml(cat.tag)}</span></td>
      <td>${triaged ? badge('Done', 'green') : badge('Pending', 'yellow')}</td>
      <td>${specBadge}</td>
      <td>${gooseBadge}</td>
      <td>${implBadge}</td>
      <td>${mergedBadge}</td>
      <td style="color:var(--muted)">${escHtml(age)}</td>
    </tr>`;
  });

  tbody.innerHTML = rows.join('');
}

function renderActiveRuns(runs) {
  const el = document.getElementById('active-runs');
  const active = runs.workflow_runs.filter(r =>
    r.status === 'in_progress' || r.status === 'queued' || r.status === 'pending'
  ).slice(0, 12);

  if (active.length === 0) {
    el.innerHTML = '<li class="empty">No active runs</li>';
    return;
  }

  el.innerHTML = active.map(r => `
    <li class="run-item">
      ${runIcon(r.status, r.conclusion)}
      <a href="${escAttr(r.html_url)}" style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"
        title="${escAttr(r.display_title || r.name)}">${escHtml(r.name)}</a>
      <span style="color:var(--muted);font-size:0.75rem;white-space:nowrap">${escHtml(timeAgo(r.created_at))}</span>
    </li>
  `).join('');
}

function renderRecentRuns(runs) {
  const el = document.getElementById('recent-runs');
  const recent = runs.workflow_runs.filter(r =>
    r.status === 'completed' &&
    ['Goose Implementation', 'Spec Auto-Approve', 'Auto-merge on CI pass', 'Copilot Issue Triage'].includes(r.name)
  ).slice(0, 10);

  if (recent.length === 0) {
    el.innerHTML = '<li class="empty">No recent runs</li>';
    return;
  }

  el.innerHTML = recent.map(r => `
    <li class="run-item">
      ${runIcon(r.status, r.conclusion)}
      <a href="${escAttr(r.html_url)}" style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"
        title="${escAttr(r.display_title || r.name)}">${escHtml(r.name)}</a>
      <span style="color:var(--muted);font-size:0.75rem;white-space:nowrap">${escHtml(timeAgo(r.updated_at))}</span>
    </li>
  `).join('');
}

// ── mem0 Statistics ──
// Parses Goose Implementation run job logs to extract mem0 retrieve/save stats.
// Uses the Jobs API: /actions/runs/{id}/jobs — 1 API call per run.
// We only parse the 3 most recent completed Goose runs, and cache results.

const mem0Cache = {};

async function fetchMem0Stats(runs) {
  const gooseRuns = runs.workflow_runs.filter(r =>
    r.name === 'Goose Implementation' && r.status === 'completed'
  ).slice(0, 5);

  if (gooseRuns.length === 0) {
    renderMem0Empty();
    return;
  }

  // Fetch jobs for runs we haven't cached yet (max 2 new fetches per cycle)
  let fetched = 0;
  for (const run of gooseRuns) {
    if (mem0Cache[run.id] || fetched >= 2) continue;
    try {
      const jobsData = await ghFetch(`/actions/runs/${run.id}/jobs`);
      const job = (jobsData.jobs || [])[0];
      if (!job) continue;

      // Extract mem0 stats from step names and conclusions
      const steps = job.steps || [];
      const retrieveStep = steps.find(s => s.name && s.name.includes('Retrieve memories'));
      const saveStep = steps.find(s => s.name && s.name.includes('Save memories'));
      const encryptStep = steps.find(s => s.name && s.name.includes('Encrypt mem0'));
      const cacheStep = steps.find(s => s.name && s.name.includes('Save mem0 memory cache'));
      const restoreStep = steps.find(s => s.name && s.name.includes('Restore mem0 memory cache'));

      mem0Cache[run.id] = {
        runId: run.id,
        runUrl: run.html_url,
        conclusion: run.conclusion,
        createdAt: run.created_at,
        issueTitle: run.display_title || '',
        retrieve: {
          status: retrieveStep?.conclusion || 'skipped',
          ran: !!retrieveStep,
        },
        save: {
          status: saveStep?.conclusion || 'skipped',
          ran: !!saveStep,
        },
        encrypt: {
          status: encryptStep?.conclusion || 'skipped',
          ran: !!encryptStep,
        },
        cacheRestore: restoreStep?.conclusion || 'skipped',
        cacheSave: cacheStep?.conclusion || 'skipped',
      };
      fetched++;
    } catch {
      // Rate limit or other error — skip
    }
  }

  renderMem0(gooseRuns);
}

function renderMem0Empty() {
  document.getElementById('mem0-status').innerHTML = badge('No Data', 'muted');
  document.getElementById('mem0-retrieved').textContent = '-';
  document.getElementById('mem0-saved').textContent = '-';
  document.getElementById('mem0-cache').innerHTML = badge('Unknown', 'muted');
  document.getElementById('mem0-history').innerHTML = '<li class="empty">No Goose runs found</li>';
}

function renderMem0(gooseRuns) {
  const entries = gooseRuns.map(r => mem0Cache[r.id]).filter(Boolean);

  if (entries.length === 0) {
    renderMem0Empty();
    return;
  }

  const latest = entries[0];

  // Status: check if retrieve and save both succeeded
  const retrieveOk = latest.retrieve.ran && latest.retrieve.status === 'success';
  const saveOk = latest.save.ran && latest.save.status === 'success';
  const encryptOk = latest.encrypt.ran && latest.encrypt.status === 'success';

  let statusBadge;
  if (retrieveOk && saveOk) {
    statusBadge = badge('Healthy', 'green');
  } else if (latest.retrieve.ran || latest.save.ran) {
    // Steps ran but may have had issues (the BaseLlmConfig bug)
    statusBadge = badge('Degraded', 'yellow');
  } else {
    statusBadge = badge('Disabled', 'muted');
  }
  document.getElementById('mem0-status').innerHTML = statusBadge;

  // Retrieve/save — we can't get exact counts without log parsing,
  // but we can show step success/failure
  document.getElementById('mem0-retrieved').innerHTML =
    latest.retrieve.ran
      ? (retrieveOk ? badge('OK', 'green') : badge('Failed', 'red'))
      : badge('Skipped', 'muted');

  document.getElementById('mem0-saved').innerHTML =
    latest.save.ran
      ? (saveOk ? badge('OK', 'green') : badge('Failed', 'red'))
      : badge('Skipped', 'muted');

  // Cache status
  document.getElementById('mem0-cache').innerHTML =
    encryptOk
      ? badge('Encrypted + Cached', 'green')
      : latest.cacheSave === 'success'
        ? badge('Cached (unencrypted)', 'yellow')
        : badge('Not cached', 'red');

  // History list
  const historyEl = document.getElementById('mem0-history');
  historyEl.innerHTML = entries.map(e => {
    const retrieveBadge = e.retrieve.ran
      ? (e.retrieve.status === 'success' ? badge('Retrieved', 'green') : badge('Retrieve failed', 'red'))
      : badge('No retrieve', 'muted');
    const saveBadge = e.save.ran
      ? (e.save.status === 'success' ? badge('Saved', 'green') : badge('Save failed', 'red'))
      : badge('No save', 'muted');

    return `<li class="run-item">
      ${runIcon('completed', e.conclusion)}
      <a href="${escAttr(e.runUrl)}" style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"
        title="${escAttr(e.issueTitle)}">${escHtml(e.issueTitle.substring(0, 40))}</a>
      ${retrieveBadge} ${saveBadge}
      <span style="color:var(--muted);font-size:0.75rem;white-space:nowrap">${escHtml(timeAgo(e.createdAt))}</span>
    </li>`;
  }).join('');
}

// ── Init ──
fetchAll();
setInterval(fetchAll, 120000); // 2 minutes — stays within rate limits
</script>
</body>
</html>
