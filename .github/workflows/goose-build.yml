name: Goose Implementation

# Triggered when:
# 1. A spec PR is labeled 'approved-for-build' (normal flow)
# 2. Manually via workflow_dispatch (re-trigger for merged PRs or retries)

on:
  pull_request:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to implement (e.g. 24)'
        required: true
        type: string
      spec_pr_number:
        description: 'Spec PR number (for tracking, e.g. 28)'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  GOOSE_PROVIDER: google
  GOOSE_MODEL: gemini-2.5-flash
  # Goose requires the provider-specific key
  GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}

jobs:
  implement:
    if: >-
      github.event_name == 'workflow_dispatch' ||
      github.event.label.name == 'approved-for-build'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    concurrency:
      group: >-
        goose-implement-${{
          github.event_name == 'workflow_dispatch'
          && github.event.inputs.issue_number
          || github.event.pull_request.number
        }}
      cancel-in-progress: false

    steps:
      # ── Validate prerequisites ──────────────────────────
      - name: Validate API key is configured
        env:
          KEY: ${{ secrets.GOOGLE_API_KEY }}
        run: |
          if [ -z "$KEY" ]; then
            echo "::error::GOOGLE_API_KEY secret is not configured. Add it in Settings > Secrets > Actions."
            exit 1
          fi

      - name: Verify authorization
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            if (context.eventName === 'workflow_dispatch') {
              // workflow_dispatch already requires write access to trigger
              console.log(`Manual dispatch by @${context.actor}`);
              return;
            }

            // For PR label events, verify the sender has write access
            const pr = context.payload.pull_request;
            console.log(`Spec PR branch: ${pr.head.ref}`);

            const sender = context.payload.sender;
            if (sender) {
              try {
                const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  username: sender.login
                });
                if (!['admin', 'write'].includes(perm.permission)) {
                  core.setFailed(`Label applied by @${sender.login} who lacks write access (has: ${perm.permission})`);
                  return;
                }
                console.log(`Label applied by @${sender.login} (${perm.permission} access)`);
              } catch (error) {
                core.setFailed(`Failed to verify permissions for @${sender.login}: ${error.message}`);
                return;
              }
            }

      # ── Setup ──────────────────────────────────────────
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23"

      - name: Install Goose CLI
        run: |
          # Using latest release. To pin, replace URL with:
          #   releases/download/vX.Y.Z/download_cli.sh
          curl -fsSL "https://github.com/block/goose/releases/latest/download/download_cli.sh" \
            -o /tmp/goose-install.sh
          CONFIGURE=false bash /tmp/goose-install.sh
          rm /tmp/goose-install.sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          # Verify installation
          $HOME/.local/bin/goose --version

      # ── Extract spec details ───────────────────────────
      - name: Extract issue number and spec metadata
        id: spec
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let issueNumber, specBranch, specPRNumber;

            if (context.eventName === 'workflow_dispatch') {
              // Manual trigger — inputs provided directly
              issueNumber = context.payload.inputs.issue_number;
              specPRNumber = context.payload.inputs.spec_pr_number;

              // Look up the spec PR to find its branch (may be merged)
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: parseInt(specPRNumber),
              });
              specBranch = pr.head.ref;
              console.log(`Manual dispatch: issue #${issueNumber}, spec PR #${specPRNumber} (${pr.state})`);
            } else {
              // PR label trigger — extract from PR context
              const pr = context.payload.pull_request;

              // Prefer extracting issue number from the spec filename in PR changes.
              const files = await github.paginate(github.rest.pulls.listFiles, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                per_page: 100,
              });

              issueNumber = null;
              for (const file of files) {
                const match = file.filename.match(/^specs\/issue-(\d+)-spec\.md$/);
                if (match) {
                  issueNumber = match[1];
                  break;
                }
              }

              // Backward-compatible fallback for older PRs.
              if (!issueNumber) {
                const titleMatch = pr.title.match(/Issue #(\d+)/);
                if (titleMatch) {
                  issueNumber = titleMatch[1];
                }
              }

              if (!issueNumber) {
                core.setFailed(
                  'Could not extract issue number from spec filename or PR title. ' +
                  'Expected changed file like specs/issue-N-spec.md or title containing "Issue #N". ' +
                  'PR title: ' + pr.title
                );
                return;
              }

              specBranch = pr.head.ref;
              specPRNumber = String(pr.number);
            }

            core.setOutput('issue_number', issueNumber);
            core.setOutput('spec_branch', specBranch);
            core.setOutput('spec_pr_number', specPRNumber);
            core.setOutput('impl_branch', `goose/issue-${issueNumber}`);

            console.log(`Issue: #${issueNumber}`);
            console.log(`Spec branch: ${specBranch}`);
            console.log(`Spec PR: #${specPRNumber}`);

      - name: Fetch spec file
        run: |
          SPEC_FILE="specs/issue-${{ steps.spec.outputs.issue_number }}-spec.md"

          # Check if spec file already exists on main (merged PR case)
          if [ -f "$SPEC_FILE" ]; then
            echo "Spec file found on main (already merged)"
          else
            # Try fetching from the spec branch
            echo "Fetching spec from branch: ${{ steps.spec.outputs.spec_branch }}"
            git fetch origin ${{ steps.spec.outputs.spec_branch }} 2>/dev/null || true
            git checkout origin/${{ steps.spec.outputs.spec_branch }} -- "$SPEC_FILE" 2>/dev/null || true
          fi

          if [ ! -f "$SPEC_FILE" ]; then
            echo "::error::Spec file not found: $SPEC_FILE"
            echo "Listing specs/ directory:"
            ls -la specs/ 2>/dev/null || echo "specs/ directory does not exist"
            exit 1
          fi

          echo "Found spec file: $SPEC_FILE"
          echo "--- Spec Content ---"
          cat "$SPEC_FILE"
          echo "--- End Spec ---"

      # ── Prepare implementation branch ──────────────────
      - name: Create implementation branch
        run: |
          git checkout main
          BRANCH="${{ steps.spec.outputs.impl_branch }}"

          # Delete remote branch if it exists (retry scenario)
          if git ls-remote --heads origin "$BRANCH" | grep -q "refs/heads/${BRANCH}$"; then
            echo "Remote branch '$BRANCH' exists, deleting for retry..."
            git push origin --delete "$BRANCH"
          fi

          git checkout -b "$BRANCH"
          echo "Created branch: $BRANCH"

      # ── Run Goose ──────────────────────────────────────
      - name: Run Goose
        id: goose
        run: |
          echo "Starting Goose implementation..."

          # Run Goose with the implementation recipe.
          # set +e so we capture exit code even if non-zero.
          set +e
          goose run \
            --no-session \
            --recipe .github/goose-recipes/wgmesh-implementation.yaml \
            --params spec_file="specs/issue-${{ steps.spec.outputs.issue_number }}-spec.md" \
            2>&1 | tee /tmp/goose-output.log
          GOOSE_EXIT=$?
          set -e

          echo "Goose finished with exit code: $GOOSE_EXIT"

          # Detect silent failures: Goose often exits 0 even on errors
          ERRORS_FOUND=false

          if grep -qiE "rate.?limit|quota.?exceeded|resource.?exhausted|429|too many requests" /tmp/goose-output.log; then
            echo "::error::Goose hit API rate limits or quota exhaustion"
            ERRORS_FOUND=true
          fi

          if grep -qiE "unauthorized|authentication|invalid.?api.?key|403|401" /tmp/goose-output.log; then
            echo "::error::Goose encountered authentication/authorization errors"
            ERRORS_FOUND=true
          fi

          if grep -qi "unexpected argument" /tmp/goose-output.log; then
            echo "::error::Goose CLI argument error detected"
            ERRORS_FOUND=true
          fi

          # Check if output is suspiciously short (Goose didn't actually run)
          LINES=$(wc -l < /tmp/goose-output.log)
          if [ "$LINES" -lt 5 ]; then
            echo "::error::Goose output is suspiciously short ($LINES lines) — likely did not execute"
            ERRORS_FOUND=true
          fi

          if [ "$GOOSE_EXIT" -ne 0 ] || [ "$ERRORS_FOUND" = "true" ]; then
            echo "::error::Goose failed (exit=$GOOSE_EXIT, errors_detected=$ERRORS_FOUND)"
            echo "--- Last 50 lines of Goose output ---"
            tail -50 /tmp/goose-output.log
            exit 1
          fi

      # ── Commit and push ────────────────────────────────
      - name: Check for changes and commit
        id: commit
        run: |
          # Stage all changes except the spec file (it belongs to the spec PR)
          git add -A
          # Unstage the spec file if it was added
          git reset HEAD -- "specs/issue-${{ steps.spec.outputs.issue_number }}-spec.md" 2>/dev/null || true

          if git diff --cached --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "::warning::Goose did not produce any code changes"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT

            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

            git commit -m "impl: Issue #${{ steps.spec.outputs.issue_number }} - Goose implementation

            Automated implementation based on specification from PR #${{ steps.spec.outputs.spec_pr_number }}.
            Generated by Goose (block/goose) with ${{ env.GOOSE_MODEL }}."

            git push origin ${{ steps.spec.outputs.impl_branch }}
            echo "Pushed implementation to ${{ steps.spec.outputs.impl_branch }}"
          fi

      # ── Create implementation PR ───────────────────────
      - name: Create implementation PR
        if: steps.commit.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNum = '${{ steps.spec.outputs.issue_number }}';
            const specPR = '${{ steps.spec.outputs.spec_pr_number }}';
            const implBranch = '${{ steps.spec.outputs.impl_branch }}';

            // Create draft PR
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `impl: Issue #${issueNum} - Goose implementation`,
              head: implBranch,
              base: 'main',
              draft: true,
              body: [
                `## Goose Implementation`,
                ``,
                `Automated implementation for **Issue #${issueNum}**`,
                `Based on specification from **PR #${specPR}**`,
                ``,
                `### Pipeline`,
                ``,
                `| Step | Status |`,
                `|------|--------|`,
                `| Issue created | #${issueNum} |`,
                `| Copilot spec | PR #${specPR} |`,
                `| Human approval | Approved |`,
                `| Goose implementation | This PR |`,
                `| Human code review | **Pending** |`,
                ``,
                `### Review Checklist`,
                ``,
                `- [ ] Code changes match the specification`,
                `- [ ] Tests pass and cover the changes`,
                `- [ ] No unintended side effects`,
                `- [ ] Code style follows project conventions`,
                `- [ ] Security considerations addressed`,
                ``,
                `---`,
                `*This PR was automatically generated by [Goose](https://github.com/block/goose).*`,
                `*Please review carefully before merging.*`,
              ].join('\n')
            });

            // Label the implementation PR
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['goose-implementation', 'needs-review']
            });

            // Comment on the original issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issueNum),
              body: [
                `Goose has created an implementation: **PR #${pr.number}**`,
                ``,
                `| Step | Link |`,
                `|------|------|`,
                `| Spec | PR #${specPR} |`,
                `| Implementation | PR #${pr.number} |`,
                ``,
                `Please review the implementation PR.`,
              ].join('\n')
            });

            // Also comment on the spec PR
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(specPR),
              body: `Implementation PR created: #${pr.number}`
            });

            console.log(`Created implementation PR #${pr.number}`);

      # ── Handle no-changes case ─────────────────────────
      - name: Report no changes
        if: steps.commit.outputs.has_changes == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const specPR = '${{ steps.spec.outputs.spec_pr_number }}';
            const issueNum = '${{ steps.spec.outputs.issue_number }}';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(specPR),
              body: [
                `**Goose did not produce any code changes.**`,
                ``,
                `This may mean:`,
                `- The spec was classified as "wont-do" or "needs-info"`,
                `- Goose could not determine what changes to make`,
                `- The implementation ran into errors`,
                ``,
                `Check the [workflow run](${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${process.env.GITHUB_RUN_ID}) for details.`,
              ].join('\n')
            });
