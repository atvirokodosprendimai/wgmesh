name: Goose Implementation

# Triggered when:
# 1. A spec PR is labeled 'approved-for-build' (normal flow)
# 2. Manually via workflow_dispatch (re-trigger for merged PRs or retries)

on:
  pull_request:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to implement (e.g. 24)'
        required: true
        type: string
      spec_pr_number:
        description: 'Spec PR number (for tracking, e.g. 28)'
        required: true
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  GOOSE_PROVIDER: anthropic
  GOOSE_MODEL: GLM-4.7
  ANTHROPIC_API_KEY: ${{ secrets.ZAI_API_KEY }}
  ANTHROPIC_HOST: https://api.z.ai/api/anthropic

jobs:
  implement:
    if: >-
      github.event_name == 'workflow_dispatch' ||
      github.event.label.name == 'approved-for-build'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    concurrency:
      group: >-
        goose-implement-${{
          github.event_name == 'workflow_dispatch'
          && github.event.inputs.issue_number
          || github.event.pull_request.number
        }}
      cancel-in-progress: false

    steps:
      # ── Validate prerequisites ──────────────────────────
      - name: Validate API key is configured
        env:
          KEY: ${{ secrets.ZAI_API_KEY }}
        run: |
          if [ -z "$KEY" ]; then
            echo "::error::ZAI_API_KEY secret is not configured. Add it in Settings > Secrets > Actions."
            exit 1
          fi

      - name: Verify authorization
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            if (context.eventName === 'workflow_dispatch') {
              // workflow_dispatch already requires write access to trigger
              console.log(`Manual dispatch by @${context.actor}`);
              return;
            }

            // For PR label events, verify the sender has write access
            const pr = context.payload.pull_request;
            console.log(`Spec PR branch: ${pr.head.ref}`);

            const sender = context.payload.sender;
            if (sender) {
              try {
                const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  username: sender.login
                });
                if (!['admin', 'write'].includes(perm.permission)) {
                  core.setFailed(`Label applied by @${sender.login} who lacks write access (has: ${perm.permission})`);
                  return;
                }
                console.log(`Label applied by @${sender.login} (${perm.permission} access)`);
              } catch (error) {
                core.setFailed(`Failed to verify permissions for @${sender.login}: ${error.message}`);
                return;
              }
            }

      # ── Setup ──────────────────────────────────────────
      # PUSH_TOKEN is a PAT with 'repo' + 'workflow' scopes.
      # Required because GITHUB_TOKEN cannot push workflow file changes.
      # Falls back to GITHUB_TOKEN for non-workflow changes.
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.PUSH_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23"

      - name: Install Goose CLI
        run: |
          # Using latest release. To pin, replace URL with:
          #   releases/download/vX.Y.Z/download_cli.sh
          curl -fsSL "https://github.com/block/goose/releases/latest/download/download_cli.sh" \
            -o /tmp/goose-install.sh
          CONFIGURE=false bash /tmp/goose-install.sh
          rm /tmp/goose-install.sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          # Verify installation
          $HOME/.local/bin/goose --version

      # ── Extract spec details ───────────────────────────
      - name: Extract issue number and spec metadata
        id: spec
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let issueNumber, specBranch, specPRNumber;

            if (context.eventName === 'workflow_dispatch') {
              // Manual trigger — inputs provided directly
              issueNumber = context.payload.inputs.issue_number;
              specPRNumber = context.payload.inputs.spec_pr_number;

              // Look up the spec PR to find its branch (may be merged)
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: parseInt(specPRNumber),
              });
              specBranch = pr.head.ref;
              console.log(`Manual dispatch: issue #${issueNumber}, spec PR #${specPRNumber} (${pr.state})`);
            } else {
              // PR label trigger — extract from PR context
              const pr = context.payload.pull_request;

              // Prefer extracting issue number from the spec filename in PR changes.
              const files = await github.paginate(github.rest.pulls.listFiles, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                per_page: 100,
              });

              issueNumber = null;
              for (const file of files) {
                const match = file.filename.match(/^specs\/issue-(\d+)-spec\.md$/);
                if (match) {
                  issueNumber = match[1];
                  break;
                }
              }

              // Backward-compatible fallback for older PRs.
              if (!issueNumber) {
                const titleMatch = pr.title.match(/Issue #(\d+)/);
                if (titleMatch) {
                  issueNumber = titleMatch[1];
                }
              }

              if (!issueNumber) {
                core.setFailed(
                  'Could not extract issue number from spec filename or PR title. ' +
                  'Expected changed file like specs/issue-N-spec.md or title containing "Issue #N". ' +
                  'PR title: ' + pr.title
                );
                return;
              }

              specBranch = pr.head.ref;
              specPRNumber = String(pr.number);
            }

            core.setOutput('issue_number', issueNumber);
            core.setOutput('spec_branch', specBranch);
            core.setOutput('spec_pr_number', specPRNumber);
            core.setOutput('impl_branch', `goose/issue-${issueNumber}`);

            console.log(`Issue: #${issueNumber}`);
            console.log(`Spec branch: ${specBranch}`);
            console.log(`Spec PR: #${specPRNumber}`);

      - name: Fetch spec file
        run: |
          SPEC_FILE="specs/issue-${{ steps.spec.outputs.issue_number }}-spec.md"

          # Check if spec file already exists on main (merged PR case)
          if [ -f "$SPEC_FILE" ]; then
            echo "Spec file found on main (already merged)"
          else
            # Try fetching from the spec branch
            echo "Fetching spec from branch: ${{ steps.spec.outputs.spec_branch }}"
            git fetch origin ${{ steps.spec.outputs.spec_branch }} 2>/dev/null || true
            git checkout origin/${{ steps.spec.outputs.spec_branch }} -- "$SPEC_FILE" 2>/dev/null || true
          fi

          if [ ! -f "$SPEC_FILE" ]; then
            echo "::error::Spec file not found: $SPEC_FILE"
            echo "Listing specs/ directory:"
            ls -la specs/ 2>/dev/null || echo "specs/ directory does not exist"
            exit 1
          fi

          echo "Found spec file: $SPEC_FILE"
          echo "--- Spec Content ---"
          cat "$SPEC_FILE"
          echo "--- End Spec ---"

      # ── Prepare implementation branch ──────────────────
      - name: Create implementation branch
        run: |
          git checkout main
          BRANCH="${{ steps.spec.outputs.impl_branch }}"

          # Delete remote branch if it exists (retry scenario)
          if git ls-remote --heads origin "$BRANCH" | grep -q "refs/heads/${BRANCH}$"; then
            echo "Remote branch '$BRANCH' exists, deleting for retry..."
            git push origin --delete "$BRANCH"
          fi

          git checkout -b "$BRANCH"
          echo "Created branch: $BRANCH"

      # ── Build Goose instructions ─────────────────────────
      - name: Build Goose instructions
        run: |
          ISSUE_NUM="${{ steps.spec.outputs.issue_number }}"
          SPEC_FILE="specs/issue-${ISSUE_NUM}-spec.md"

          cat > /tmp/goose-task.md << 'TASK_HEADER'
          # Implementation Task for wgmesh

          You are implementing code changes for the wgmesh project.
          wgmesh is a Go 1.23 WireGuard mesh network builder.

          ## Project Rules

          - Language: Go 1.23, module: github.com/atvirokodosprendimai/wgmesh
          - Build: `go build` (must succeed)
          - Test: `go test ./...` (must pass)
          - Lint: `go vet ./...` (must be clean)
          - Format: code must be `gofmt` formatted
          - Always handle errors with context wrapping
          - Use standard library where possible
          - Do NOT modify files outside the scope of the specification below

          ## Specification

          TASK_HEADER

          # Append the actual spec content
          cat "$SPEC_FILE" >> /tmp/goose-task.md

          cat >> /tmp/goose-task.md << 'TASK_FOOTER'

          ## Implementation Checklist

          Follow these steps in order:

          1. Read the specification above thoroughly
          2. Explore the relevant source files mentioned in "Affected Files"
          3. Implement the changes described in "Proposed Approach"
          4. Write or update unit tests for your changes
          5. Run `go build` and fix any compilation errors
          6. Run `go test ./...` and fix any test failures
          7. Run `go vet ./...` and fix any issues
          8. Run `gofmt -l .` to verify formatting (fix with `gofmt -w .` if needed)
          9. Keep changes minimal and focused - do not refactor unrelated code

          IMPORTANT: If the spec classification is "wont-do" or "needs-info",
          do NOT implement anything. Just create a brief note explaining why.
          TASK_FOOTER

          echo "Goose instructions written to /tmp/goose-task.md"
          wc -l /tmp/goose-task.md

      # ── Run Goose ──────────────────────────────────────
      - name: Run Goose
        id: goose
        run: |
          MAX_ATTEMPTS=3
          BACKOFF=30  # initial delay in seconds
          SUCCEEDED=false

          for ATTEMPT in $(seq 1 $MAX_ATTEMPTS); do
            echo "=== Goose attempt $ATTEMPT/$MAX_ATTEMPTS ==="

            # Reset working tree to clean state for retries
            if [ "$ATTEMPT" -gt 1 ]; then
              echo "Restoring clean state for retry..."
              git checkout -- . 2>/dev/null || true
              git clean -fd 2>/dev/null || true
            fi

            set +e
            goose run \
              --no-session \
              --with-builtin "developer" \
              -i /tmp/goose-task.md \
              --max-turns 50 \
              2>&1 | tee /tmp/goose-output.log
            GOOSE_EXIT=$?
            set -e

            echo "Goose finished with exit code: $GOOSE_EXIT"

            # ── Check for non-recoverable errors (fail immediately) ──
            # Use narrow patterns to avoid false positives from code/docs
            # that Goose reads or writes containing words like "authentication"
            if grep -qiE "401 unauthorized|authentication failed|invalid.?api.?key|api key is invalid" /tmp/goose-output.log; then
              echo "::error::Goose encountered authentication errors (non-recoverable)"
              tail -30 /tmp/goose-output.log
              exit 1
            fi

            if grep -qi "unexpected argument" /tmp/goose-output.log; then
              echo "::error::Goose CLI argument error (non-recoverable)"
              tail -30 /tmp/goose-output.log
              exit 1
            fi

            # ── Check if output is suspiciously short ──
            LINES=$(wc -l < /tmp/goose-output.log)
            TOO_SHORT=false
            if [ "$LINES" -lt 5 ]; then
              TOO_SHORT=true
            fi

            # ── Success: meaningful output with completion signals ──
            # Goose CLI often exits 1 even on successful completion,
            # so we check output quality rather than relying on exit code alone.
            # Goose may log rate-limit messages from the LLM provider mid-run
            # (which it handles internally with its own retries) and still
            # complete successfully. Check for positive success signals first
            # to avoid treating a successful run as a rate-limit failure.
            HAS_SUCCESS_SIGNALS=false
            if grep -qE "(go build|go test|gofmt|go vet).*(succeeded|passed|pass|clean|no issues)" /tmp/goose-output.log || \
               grep -qE "All (validation|acceptance|checks)" /tmp/goose-output.log || \
               grep -qE "Implementation (complete|done|finished)" /tmp/goose-output.log; then
              HAS_SUCCESS_SIGNALS=true
            fi

            if [ "$TOO_SHORT" = "false" ] && [ "$HAS_SUCCESS_SIGNALS" = "true" ]; then
              echo "Goose completed on attempt $ATTEMPT (exit=$GOOSE_EXIT, success signals detected)"
              SUCCEEDED=true
              break
            fi

            # ── Check for rate limit errors (retryable) ──
            # Only treated as failure when no success signals were found above.
            # Use specific patterns to avoid false positives from source code
            # line numbers (e.g. "429: fmt.Println()") or docs containing these words
            RATE_LIMITED=false
            if grep -qiE "rate.?limit.?(exceeded|hit|reached)|quota.?exceeded|resource.?exhausted|HTTP.?429|status.?429|too many requests" /tmp/goose-output.log; then
              RATE_LIMITED=true
            fi

            # ── If no success signals and no rate limit, still accept long output ──
            if [ "$TOO_SHORT" = "false" ] && [ "$RATE_LIMITED" = "false" ]; then
              echo "Goose completed on attempt $ATTEMPT (exit=$GOOSE_EXIT, no errors detected)"
              SUCCEEDED=true
              break
            fi

            # ── Parse retry delay from Goose output if available ──
            SUGGESTED_DELAY=$(grep -oP 'retry in \K[0-9]+' /tmp/goose-output.log 2>/dev/null | tail -1)
            if [ -n "$SUGGESTED_DELAY" ] && [ "$SUGGESTED_DELAY" -gt "$BACKOFF" ] 2>/dev/null; then
              WAIT=$((SUGGESTED_DELAY + 5))  # add 5s buffer
            else
              WAIT=$BACKOFF
            fi

            # ── Log and sleep ──
            if [ "$RATE_LIMITED" = "true" ]; then
              echo "::warning::Rate limited on attempt $ATTEMPT. Waiting ${WAIT}s before retry..."
            elif [ "$TOO_SHORT" = "true" ]; then
              echo "::warning::Suspiciously short output ($LINES lines) on attempt $ATTEMPT. Waiting ${WAIT}s..."
            else
              echo "::warning::Goose failed (exit=$GOOSE_EXIT) on attempt $ATTEMPT. Waiting ${WAIT}s..."
            fi
            sleep "$WAIT"
            BACKOFF=$((BACKOFF * 2))
          done

          if [ "$SUCCEEDED" != "true" ]; then
            echo "::error::Goose failed after $MAX_ATTEMPTS attempts"
            echo "--- Last 50 lines of Goose output ---"
            tail -50 /tmp/goose-output.log
            exit 1
          fi

      # ── Validate implementation ───────────────────────
      - name: Validate implementation
        id: validate
        run: |
          echo "=== Checking for changes ==="
          if git diff --quiet && git diff --cached --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "::warning::Goose did not produce any code changes"
            exit 0
          fi
          echo "has_changes=true" >> $GITHUB_OUTPUT

          echo "=== Running go build ==="
          if ! go build ./...; then
            echo "::error::go build failed on Goose's changes"
            exit 1
          fi

          echo "=== Running go test ==="
          if ! go test ./...; then
            echo "::error::go test failed on Goose's changes"
            exit 1
          fi

          echo "=== Running go vet ==="
          if ! go vet ./...; then
            echo "::error::go vet failed on Goose's changes"
            exit 1
          fi

          echo "=== Checking gofmt ==="
          UNFORMATTED=$(gofmt -l .)
          if [ -n "$UNFORMATTED" ]; then
            echo "::error::gofmt found unformatted files: $UNFORMATTED"
            exit 1
          fi

          echo "All validation checks passed"

      # ── Commit and push ────────────────────────────────
      - name: Commit and push
        id: commit
        if: steps.validate.outputs.has_changes == 'true'
        run: |
          # Stage all changes except the spec file (it belongs to the spec PR)
          git add -A
          # Unstage the spec file if it was added
          git reset HEAD -- "specs/issue-${{ steps.spec.outputs.issue_number }}-spec.md" 2>/dev/null || true

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git commit -m "impl: Issue #${{ steps.spec.outputs.issue_number }} - Goose implementation

          Automated implementation based on specification from PR #${{ steps.spec.outputs.spec_pr_number }}.
          Generated by Goose (block/goose) with ${{ env.GOOSE_MODEL }}.
          Validated: go build, go test, go vet, gofmt all passed."

          git push origin ${{ steps.spec.outputs.impl_branch }}
          echo "Pushed implementation to ${{ steps.spec.outputs.impl_branch }}"

      # ── Create implementation PR ───────────────────────
      - name: Create implementation PR
        if: steps.validate.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNum = '${{ steps.spec.outputs.issue_number }}';
            const specPR = '${{ steps.spec.outputs.spec_pr_number }}';
            const implBranch = '${{ steps.spec.outputs.impl_branch }}';

            // Create PR (ready for review)
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `impl: Issue #${issueNum} - Goose implementation`,
              head: implBranch,
              base: 'main',
              draft: false,
              body: [
                `## Goose Implementation`,
                ``,
                `Automated implementation for **Issue #${issueNum}**`,
                `Based on specification from **PR #${specPR}**`,
                ``,
                `### Pipeline`,
                ``,
                `| Step | Status |`,
                `|------|--------|`,
                `| Issue created | #${issueNum} |`,
                `| Copilot spec | PR #${specPR} |`,
                `| Human approval | Approved |`,
                `| Goose implementation | This PR |`,
                `| Human code review | **Pending** |`,
                ``,
                `### CI Validation (pre-PR)`,
                ``,
                `- [x] \`go build ./...\` passed`,
                `- [x] \`go test ./...\` passed`,
                `- [x] \`go vet ./...\` passed`,
                `- [x] \`gofmt\` formatting verified`,
                ``,
                `### Downloads`,
                ``,
                `Build artifacts will be available once CI completes: **[Download artifacts](${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions?query=branch%3A${implBranch})**`,
                ``,
                `---`,
                `*Generated by [Goose](https://github.com/block/goose) with ${process.env.GOOSE_MODEL}. Auto-merges after approval.*`,
              ].join('\n')
            });

            // Enable auto-merge (merges automatically once reviews and checks pass)
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              merge_method: 'squash',
            }).catch(() => {
              // Expected to fail if branch protection blocks immediate merge.
              // Enable auto-merge via GraphQL instead.
            });

            await github.graphql(`
              mutation($prId: ID!) {
                enablePullRequestAutoMerge(input: {pullRequestId: $prId, mergeMethod: SQUASH}) {
                  clientMutationId
                }
              }
            `, { prId: pr.node_id });

            console.log(`Auto-merge enabled for PR #${pr.number}`);

            // Label the implementation PR
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['goose-implementation', 'needs-review']
            });

            // Comment on the original issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issueNum),
              body: [
                `Goose has created an implementation: **PR #${pr.number}**`,
                ``,
                `| Step | Link |`,
                `|------|------|`,
                `| Spec | PR #${specPR} |`,
                `| Implementation | PR #${pr.number} |`,
                ``,
                `Please review the implementation PR.`,
              ].join('\n')
            });

            // Also comment on the spec PR
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(specPR),
              body: `Implementation PR created: #${pr.number}`
            });

            console.log(`Created implementation PR #${pr.number}`);

      # ── Handle no-changes case ─────────────────────────
      - name: Report no changes
        if: steps.validate.outputs.has_changes == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const specPR = '${{ steps.spec.outputs.spec_pr_number }}';
            const issueNum = '${{ steps.spec.outputs.issue_number }}';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(specPR),
              body: [
                `**Goose did not produce any code changes.**`,
                ``,
                `This may mean:`,
                `- The spec was classified as "wont-do" or "needs-info"`,
                `- Goose could not determine what changes to make`,
                `- The implementation ran into errors`,
                ``,
                `Check the [workflow run](${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${process.env.GITHUB_RUN_ID}) for details.`,
              ].join('\n')
            });
