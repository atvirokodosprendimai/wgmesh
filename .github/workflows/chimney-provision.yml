name: Chimney Provision
# re-parse trigger

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - provision
          - teardown
          - status
          - rebuild
      locations:
        description: 'Comma-separated Hetzner locations (e.g. nbg1,ash)'
        required: false
        default: 'nbg1'

concurrency:
  group: chimney-infra
  cancel-in-progress: false

env:
  HCLOUD_TOKEN: ${{ secrets.HCLOUD_TOKEN }}
  GO_VERSION: '1.23.x'

jobs:
  provision:
    name: "Chimney: ${{ inputs.action }}"
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: inputs.action == 'provision'
    outputs:
      server_ips: ${{ steps.provision.outputs.server_ips }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build chimney binary (linux/arm64)
        run: |
          CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -v \
            -ldflags="-s -w -X main.version=chimney-${GITHUB_SHA::8}" \
            -o chimney-linux-arm64 ./cmd/chimney/
          ls -lh chimney-linux-arm64

      - name: Install hcloud CLI
        run: |
          curl -sL https://github.com/hetznercloud/cli/releases/latest/download/hcloud-linux-amd64.tar.gz \
            | tar xz -C /usr/local/bin hcloud
          hcloud version

      - name: Setup persistent SSH key
        env:
          CHIMNEY_SSH_KEY: ${{ secrets.CHIMNEY_SSH_KEY }}
          CHIMNEY_SSH_PUBKEY: ${{ secrets.CHIMNEY_SSH_PUBKEY }}
        run: |
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          echo "$CHIMNEY_SSH_KEY" > ~/.ssh/chimney && chmod 600 ~/.ssh/chimney
          echo "$CHIMNEY_SSH_PUBKEY" > ~/.ssh/chimney.pub
          echo "SSH_KEY_FILE=$HOME/.ssh/chimney" >> "$GITHUB_ENV"

      - name: Provision servers
        id: provision
        env:
          CHIMNEY_SSH_PUBKEY: ${{ secrets.CHIMNEY_SSH_PUBKEY }}
        run: |
          set -euo pipefail

          KEY_NAME="chimney-deploy-key"

          # Upload persistent deploy key (find by fingerprint to avoid uniqueness_error)
          echo "$CHIMNEY_SSH_PUBKEY" > /tmp/chimney-deploy.pub
          MD5_FP=$(ssh-keygen -E md5 -lf /tmp/chimney-deploy.pub | awk '{print $2}' | sed 's/^MD5://')
          KEY_ID=$(hcloud ssh-key list -o noheader -o columns=id,fingerprint 2>/dev/null \
            | awk -v fp="$MD5_FP" '$2==fp{print $1}' | head -1)
          if [ -z "$KEY_ID" ]; then
            hcloud ssh-key delete "$KEY_NAME" 2>/dev/null || true
            hcloud ssh-key create --name "$KEY_NAME" --public-key-from-file /tmp/chimney-deploy.pub
          else
            echo "Reusing existing Hetzner key ID: $KEY_ID"
            KEY_NAME=$(hcloud ssh-key list -o noheader -o columns=name,fingerprint \
              | awk -v fp="$MD5_FP" '$2==fp{print $1}' | head -1)
          fi

          # Build cloud-init user-data that injects our SSH pubkey on first boot.
          # This is more reliable than --ssh-key: cloud-init runs after the OS
          # boots and writes directly to authorized_keys, bypassing Hetzner's
          # key injection mechanism which can fail silently on rebuilds.
          # NOTE: no heredoc here — bare markers at column 0 break YAML parsing.
          PUB_KEY=$(cat /tmp/chimney-deploy.pub)
          printf '#cloud-config\nusers:\n  - name: root\n    ssh_authorized_keys:\n      - %s\n' "$PUB_KEY" > /tmp/cloud-init.yaml
          echo "cloud-init user-data prepared:"
          cat /tmp/cloud-init.yaml

          IFS=',' read -ra LOCATIONS <<< "${{ inputs.locations }}"
          SERVER_IPS=""

          for loc in "${LOCATIONS[@]}"; do
            loc=$(echo "$loc" | xargs)  # trim whitespace
            name="chimney-${loc}"

            # Choose server type based on location
            # cax11 (Arm64) for EU locations, cpx11 (x86) for US
            if [[ "$loc" == ash* ]]; then
              VM_TYPE="cpx11"
              ARCH="amd64"
            else
              VM_TYPE="cax11"
              ARCH="arm64"
            fi

            # Check if server already exists
            if hcloud server describe "$name" >/dev/null 2>&1; then
              echo "Server $name already exists — skipping creation"
              IP=$(hcloud server ip "$name")
            else
              echo "Creating $name ($VM_TYPE) in $loc..."
              hcloud server create \
                --name "$name" \
                --type "$VM_TYPE" \
                --image "ubuntu-24.04" \
                --location "$loc" \
                --user-data-from-file /tmp/cloud-init.yaml \
                --label "service=chimney" \
                --label "location=$loc"

              IP=$(hcloud server ip "$name")
              echo "Created $name: $IP"

              # Wait for SSH — cloud-init injects the key on first boot which can
              # take 5-10 minutes (OS boot + apt + cloud-init). Poll for up to 15min.
              echo "Waiting for SSH on $name ($IP) (cloud-init can take 10+ minutes)..."
              ssh_ready=false
              for i in $(seq 1 90); do
                if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                   -o ConnectTimeout=5 -o LogLevel=ERROR -i "$SSH_KEY_FILE" \
                   "root@${IP}" "true" 2>/dev/null; then
                  echo "SSH ready on $name after $((i * 10))s"
                  ssh_ready=true
                  break
                fi
                sleep 10
              done
              if [ "$ssh_ready" = "false" ]; then
                echo "ERROR: SSH did not become ready on $name ($IP) after 900s" >&2
                exit 1
              fi
            fi

            SERVER_IPS="${SERVER_IPS}${name}=${IP} "
          done

          echo "server_ips=${SERVER_IPS}" >> "$GITHUB_OUTPUT"
          echo "## Provisioned Servers" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"
          echo "$SERVER_IPS" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - name: Deploy chimney to servers
        run: |
          set -euo pipefail

          IFS=',' read -ra LOCATIONS <<< "${{ inputs.locations }}"

          for loc in "${LOCATIONS[@]}"; do
            loc=$(echo "$loc" | xargs)
            name="chimney-${loc}"
            IP=$(hcloud server ip "$name")

            # Determine architecture
            if [[ "$loc" == ash* ]]; then
              ARCH="amd64"
              # Need to build amd64 binary too
              echo "Building amd64 binary for $name..."
              CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -v \
                -ldflags="-s -w -X main.version=chimney-${GITHUB_SHA::8}" \
                -o chimney-linux-amd64 ./cmd/chimney/
              BINARY="chimney-linux-amd64"
            else
              ARCH="arm64"
              BINARY="chimney-linux-arm64"
            fi

            echo "Deploying to $name ($IP, $ARCH)..."

            # Copy files to server
            SCP="scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -i $SSH_KEY_FILE"
            $SCP "$BINARY"                    "root@${IP}:/tmp/chimney"
            $SCP deploy/chimney/setup.sh      "root@${IP}:/tmp/setup.sh"
            $SCP deploy/chimney/compose.yml   "root@${IP}:/tmp/compose.yml"
            $SCP deploy/chimney/Caddyfile     "root@${IP}:/tmp/Caddyfile"
            $SCP deploy/chimney/Dockerfile    "root@${IP}:/tmp/Dockerfile"
            $SCP -r docs                      "root@${IP}:/tmp/docs"

            # Run setup — pass secrets via stdin to avoid exposing in process list
            printf '%s\n%s\n' \
              '${{ secrets.PUSH_TOKEN }}' \
              '${{ secrets.WGMESH_SECRET }}' \
            | ssh -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -i "$SSH_KEY_FILE" \
                "root@${IP}" \
                'read -r GITHUB_TOKEN; read -r WGMESH_SECRET
                 export GITHUB_TOKEN WGMESH_SECRET
                 ROLE=origin bash /tmp/setup.sh'

            echo "$name deployed successfully"
          done

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "## Deployment Complete" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "Dashboard should be available at https://chimney.beerpub.dev once DNS is configured." >> "$GITHUB_STEP_SUMMARY"

      - name: Verify health
        run: |
          set -euo pipefail

          IFS=',' read -ra LOCATIONS <<< "${{ inputs.locations }}"

          for loc in "${LOCATIONS[@]}"; do
            loc=$(echo "$loc" | xargs)
            name="chimney-${loc}"
            IP=$(hcloud server ip "$name")

            echo "Checking health on $name ($IP)..."

            # Check chimney health endpoint (via IP, not domain)
            for i in $(seq 1 12); do
              if curl -sf "http://${IP}:8080/healthz" 2>/dev/null; then
                echo ""
                echo "$name: chimney healthy"
                break
              fi
              echo "Waiting for chimney on $name... (attempt $i)"
              sleep 5
            done
          done

  status:
    name: "Chimney: status"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: inputs.action == 'status'
    steps:
      - name: Install hcloud CLI
        run: |
          curl -sL https://github.com/hetznercloud/cli/releases/latest/download/hcloud-linux-amd64.tar.gz \
            | tar xz -C /usr/local/bin hcloud

      - name: Auto-recover labels on chimney servers
        run: |
          set -euo pipefail

          IFS=',' read -ra LOCATIONS <<< "${{ inputs.locations }}"

          for loc in "${LOCATIONS[@]}"; do
            loc=$(echo "$loc" | xargs)
            name="chimney-${loc}"

            if hcloud server describe "$name" >/dev/null 2>&1; then
              # Check service label
              SERVICE_LABEL=$(hcloud server describe "$name" -o json | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('labels',{}).get('service',''))")
              if [ "$SERVICE_LABEL" != "chimney" ]; then
                echo "Adding missing service=chimney label to $name"
                hcloud server add-label "$name" "service=chimney"
              else
                echo "$name: service label OK"
              fi

              # Check location label separately
              LOCATION_LABEL=$(hcloud server describe "$name" -o json | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('labels',{}).get('location',''))")
              if [ -z "$LOCATION_LABEL" ]; then
                echo "Adding missing location=$loc label to $name"
                hcloud server add-label "$name" "location=$loc"
              elif [ "$LOCATION_LABEL" != "$loc" ]; then
                echo "Warning: $name has location label '$LOCATION_LABEL' (expected '$loc'), not changing it"
              else
                echo "$name: location label OK"
              fi
            else
              echo "$name: server not found"
            fi
          done

      - name: List chimney servers
        run: |
          echo "## Chimney Servers" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"
          hcloud server list -l "service=chimney" -o columns=name,status,ipv4,datacenter >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

          hcloud server list -l "service=chimney" -o columns=name,status,ipv4,datacenter

  teardown:
    name: "Chimney: teardown"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: inputs.action == 'teardown'
    steps:
      - name: Install hcloud CLI
        run: |
          curl -sL https://github.com/hetznercloud/cli/releases/latest/download/hcloud-linux-amd64.tar.gz \
            | tar xz -C /usr/local/bin hcloud

      - name: Teardown chimney servers
        run: |
          set -euo pipefail

          echo "## Chimney Teardown" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          SERVERS=$(hcloud server list -l "service=chimney" -o noheader -o columns=name 2>/dev/null) || true

          if [ -z "$SERVERS" ]; then
            echo "No chimney servers found." | tee -a "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          for name in $SERVERS; do
            echo "Deleting $name..."
            hcloud server delete "$name"
            echo "- Deleted $name" >> "$GITHUB_STEP_SUMMARY"
          done

          # Clean up SSH key
          hcloud ssh-key delete "chimney-deploy-key" 2>/dev/null || true

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "All chimney servers removed." >> "$GITHUB_STEP_SUMMARY"

  rebuild:
    name: "Chimney: rebuild with persistent SSH key"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: inputs.action == 'rebuild'
    steps:
      - name: Install hcloud CLI
        run: |
          curl -sL https://github.com/hetznercloud/cli/releases/latest/download/hcloud-linux-amd64.tar.gz \
            | tar xz -C /usr/local/bin hcloud
          hcloud version

      - name: Rebuild chimney servers with persistent deploy key
        env:
          CHIMNEY_SSH_PUBKEY: ${{ secrets.CHIMNEY_SSH_PUBKEY }}
        run: |
          set -euo pipefail

          echo "## Chimney Rebuild" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Upload persistent deploy key to Hetzner
          # Write key to file; use MD5 fingerprint for Hetzner comparison
          echo "$CHIMNEY_SSH_PUBKEY" > /tmp/chimney-persistent.pub
          # Hetzner stores MD5 fingerprints (e.g. aa:bb:cc:...) — get MD5 without prefix
          MD5_FP=$(ssh-keygen -E md5 -lf /tmp/chimney-persistent.pub | awk '{print $2}' | sed 's/^MD5://')
          echo "Key MD5 fingerprint: $MD5_FP"

          # Check if this exact fingerprint already exists in Hetzner (under any name)
          KEY_ID=$(hcloud ssh-key list -o noheader -o columns=id,fingerprint 2>/dev/null \
            | awk -v fp="$MD5_FP" '$2==fp{print $1}' | head -1)

          if [ -n "$KEY_ID" ]; then
            echo "Key already exists in Hetzner (fingerprint match) — ID: $KEY_ID"
          else
            # Delete by name in case name exists with different key, then create fresh
            KEY_NAME="chimney-persistent-key"
            hcloud ssh-key delete "$KEY_NAME" 2>/dev/null || true
            hcloud ssh-key create --name "$KEY_NAME" --public-key-from-file /tmp/chimney-persistent.pub
            KEY_ID=$(hcloud ssh-key describe "$KEY_NAME" -o json | python3 -c "import sys,json; print(json.load(sys.stdin)['id'])")
            echo "Uploaded persistent key: $KEY_NAME (ID: $KEY_ID)"
          fi

          IFS=',' read -ra LOCATIONS <<< "${{ inputs.locations }}"

          for loc in "${LOCATIONS[@]}"; do
            loc=$(echo "$loc" | xargs)
            name="chimney-${loc}"

            if ! hcloud server describe "$name" >/dev/null 2>&1; then
              echo "Server $name not found — skipping"
              continue
            fi

            SERVER_ID=$(hcloud server describe "$name" -o json | python3 -c "import sys,json; print(json.load(sys.stdin)['id'])")
            IP=$(hcloud server ip "$name")
            echo "Rebuilding $name (ID: $SERVER_ID, IP: $IP) with ubuntu-24.04 + persistent key..."

            # Rebuild via Hetzner API — keeps same IP, reinstalls OS with our key
            REBUILD_RESP=$(curl -sf -X POST \
              -H "Authorization: Bearer $HCLOUD_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"image\": \"ubuntu-24.04\", \"ssh_keys\": [${KEY_ID}]}" \
              "https://api.hetzner.cloud/v1/servers/${SERVER_ID}/actions/rebuild")

            ACTION_ID=$(echo "$REBUILD_RESP" | python3 -c "import sys,json; print(json.load(sys.stdin)['action']['id'])")
            echo "Rebuild action started: $ACTION_ID"

            # Poll until action completes (rebuild typically takes 60-120s)
            for i in $(seq 1 30); do
              ACTION_STATUS=$(curl -sf \
                -H "Authorization: Bearer $HCLOUD_TOKEN" \
                "https://api.hetzner.cloud/v1/actions/${ACTION_ID}" \
                | python3 -c "import sys,json; print(json.load(sys.stdin)['action']['status'])")
              echo "  Action status: $ACTION_STATUS (attempt $i)"
              if [ "$ACTION_STATUS" = "success" ]; then
                echo "Rebuild complete for $name"
                break
              elif [ "$ACTION_STATUS" = "error" ]; then
                echo "ERROR: rebuild action failed for $name"
                exit 1
              fi
              sleep 10
            done

            # Wait for SSH to become available with the new key
            echo "Waiting for SSH on $name ($IP) with persistent key..."
            mkdir -p ~/.ssh && chmod 700 ~/.ssh
            echo "${{ secrets.CHIMNEY_SSH_KEY }}" > ~/.ssh/chimney && chmod 600 ~/.ssh/chimney

            # Wait up to 10 minutes for SSH — rebuild boots a fresh OS image
            ssh_ready=false
            for i in $(seq 1 60); do
              if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=10 -o LogLevel=ERROR -i ~/.ssh/chimney \
                 "root@${IP}" "echo ok" 2>/dev/null | grep -q ok; then
                echo "SSH ready on $name after $((i * 10))s"
                ssh_ready=true
                break
              fi
              echo "  SSH not ready on $name yet (attempt $i/60)..."
              sleep 10
            done

            if [ "$ssh_ready" = "false" ]; then
              echo "ERROR: SSH did not become ready on $name ($IP) after 600s" >&2
              exit 1
            fi

            echo "- **$name** ($IP): rebuilt successfully, SSH accessible with persistent key" >> "$GITHUB_STEP_SUMMARY"
            echo "$name: rebuild and SSH verification complete"
          done

          # Clean up the temporary Hetzner key entry (key is now in authorized_keys on server)
          hcloud ssh-key delete "$KEY_NAME" 2>/dev/null || true

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "Rebuild complete. Run **Chimney Deploy** workflow to reinstall chimney." >> "$GITHUB_STEP_SUMMARY"

