name: Spec Auto-Approve

# Validates and auto-approves Copilot spec PRs that pass all checks.
# This triggers Goose implementation automatically, reducing manual work.
#
# Checks:
#   1. Spec file exists at specs/issue-N-spec.md
#   2. Required sections present (Classification, Problem Analysis, Proposed Approach)
#   3. No code changes (only spec file in PR)
#   4. Classification is actionable (not wont-do or needs-info)
#
# Triggers:
#   - pull_request_target: immediate reaction to new/edited spec PRs
#   - schedule (every 5 min): catches PRs where pull_request_target was
#     blocked by GitHub's actor-approval gate (e.g. Copilot bot)
#   - workflow_dispatch: manual fallback

on:
  pull_request_target:
    types: [opened, ready_for_review, edited]
    branches: [main]
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  pull-requests: write
  contents: read
  issues: write

jobs:
  # ── Event-driven path: runs immediately when a spec PR is opened/edited ──
  validate:
    if: >-
      github.event_name == 'pull_request_target' &&
      contains(github.event.pull_request.title, 'spec:')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Fetch PR changes
        env:
          GH_TOKEN: ${{ secrets.PUSH_TOKEN }}
        run: |
          gh pr checkout ${{ github.event.pull_request.number }} --detach
          git checkout ${{ github.event.pull_request.head.ref }}

      - name: Extract issue number
        id: issue
        run: |
          TITLE="${{ github.event.pull_request.title }}"
          ISSUE_NUM=$(echo "$TITLE" | grep -oP 'Issue #\K\d+' || true)
          if [ -z "$ISSUE_NUM" ]; then
            echo "::error::Could not extract issue number from PR title: $TITLE"
            exit 1
          fi
          echo "number=$ISSUE_NUM" >> $GITHUB_OUTPUT
          echo "Issue number: $ISSUE_NUM"

      - name: Validate spec
        id: validate
        env:
          ISSUE_NUM: ${{ steps.issue.outputs.number }}
        run: |
          SPEC_FILE="specs/issue-${ISSUE_NUM}-spec.md"
          REASONS=""

          # Agent metrics: track per-check results
          CHECK_SPEC_EXISTS=false
          CHECK_NO_CODE=false
          CHECK_CLASSIFICATION=false
          CHECK_PROBLEM=false
          CHECK_APPROACH=false
          CHECK_ACTIONABLE=false
          CLASSIFICATION_VALUE=""
          NON_SPEC_COUNT=0

          # Check 1: Spec file exists
          if [ ! -f "$SPEC_FILE" ]; then
            REASONS="${REASONS}- Spec file not found: $SPEC_FILE\n"
          else
            CHECK_SPEC_EXISTS=true
          fi

          # Check 2: No code changes (only spec file should be modified)
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          CODE_FILES=$(echo "$CHANGED_FILES" | grep -v "^specs/" | grep -v "^\.github/workflows/" || true)
          if [ -n "$CODE_FILES" ]; then
            NON_SPEC_COUNT=$(echo "$CODE_FILES" | grep -c . || echo 0)
            REASONS="${REASONS}- PR contains non-spec file changes:\n$CODE_FILES\n"
          else
            CHECK_NO_CODE=true
          fi

          # Check 3: Required sections present
          if [ -f "$SPEC_FILE" ]; then
            CONTENT=$(cat "$SPEC_FILE")
            
            if echo "$CONTENT" | grep -q "## Classification"; then
              CHECK_CLASSIFICATION=true
            else
              REASONS="${REASONS}- Missing required section: ## Classification\n"
            fi
            
            if echo "$CONTENT" | grep -q "## Problem Analysis"; then
              CHECK_PROBLEM=true
            else
              REASONS="${REASONS}- Missing required section: ## Problem Analysis\n"
            fi
            
            if echo "$CONTENT" | grep -q "## Proposed Approach"; then
              CHECK_APPROACH=true
            else
              REASONS="${REASONS}- Missing required section: ## Proposed Approach\n"
            fi

            # Check 4: Classification is actionable (not wont-do or needs-info)
            CLASSIFICATION_VALUE=$(echo "$CONTENT" | grep -A1 "## Classification" | tail -1 | tr '[:upper:]' '[:lower:]' | xargs || true)
            if echo "$CLASSIFICATION_VALUE" | grep -qiE "wont-do|wont do|needs-info|needs info"; then
              REASONS="${REASONS}- Classification requires human review: $CLASSIFICATION_VALUE\n"
            else
              CHECK_ACTIONABLE=true
            fi
          fi

          # Export check results for metrics
          echo "check_spec_exists=$CHECK_SPEC_EXISTS" >> $GITHUB_OUTPUT
          echo "check_no_code=$CHECK_NO_CODE" >> $GITHUB_OUTPUT
          echo "check_classification=$CHECK_CLASSIFICATION" >> $GITHUB_OUTPUT
          echo "check_problem=$CHECK_PROBLEM" >> $GITHUB_OUTPUT
          echo "check_approach=$CHECK_APPROACH" >> $GITHUB_OUTPUT
          echo "check_actionable=$CHECK_ACTIONABLE" >> $GITHUB_OUTPUT
          echo "classification=$CLASSIFICATION_VALUE" >> $GITHUB_OUTPUT
          echo "non_spec_count=$NON_SPEC_COUNT" >> $GITHUB_OUTPUT

          # Result
          if [ -z "$REASONS" ]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "reason=" >> $GITHUB_OUTPUT
            echo "All validation checks passed"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "reason<<EOF" >> $GITHUB_OUTPUT
            echo -e "$REASONS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "Validation failed"
            echo -e "$REASONS"
          fi

      - name: Auto-approve and trigger Goose
        if: steps.validate.outputs.valid == 'true'
        env:
          GH_TOKEN: ${{ secrets.PUSH_TOKEN }}
          ISSUE_NUM: ${{ steps.issue.outputs.number }}
        run: |
          PR_NUM="${{ github.event.pull_request.number }}"
          
          echo "Auto-approving spec PR #$PR_NUM"
          
          # Approve the PR
          gh pr review $PR_NUM --approve --body "## Auto-Approved ✅

          This spec PR passed all validation checks:
          
          - ✅ Spec file exists at \`specs/issue-${ISSUE_NUM}-spec.md\`
          - ✅ Required sections present (Classification, Problem Analysis, Proposed Approach)
          - ✅ No code changes detected
          - ✅ Classification is actionable
          
          Goose will now implement the code based on this specification."
          
          # Add the label for tracking
          gh pr edit $PR_NUM --add-label approved-for-build
          
          # Directly trigger Goose implementation via workflow_dispatch.
          echo "Triggering Goose implementation for issue #${ISSUE_NUM} (spec PR #${PR_NUM})"
          gh workflow run goose-build.yml \
            -f issue_number="${ISSUE_NUM}" \
            -f spec_pr_number="${PR_NUM}"
          
          echo "Goose implementation triggered"

      # ── Agent metrics: spec validation ────────────────
      - name: Collect agent metrics
        if: always()
        env:
          ISSUE_NUM: ${{ steps.issue.outputs.number }}
        run: |
          METRICS_FILE="/tmp/agent-metrics-spec-${ISSUE_NUM}.json"
          PR_CREATED="${{ github.event.pull_request.created_at }}"

          jq -n \
            --argjson schema_version 1 \
            --arg stage "spec_validate" \
            --arg issue_number "$ISSUE_NUM" \
            --arg spec_pr_number "${{ github.event.pull_request.number }}" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg pr_created_at "$PR_CREATED" \
            --arg valid "${{ steps.validate.outputs.valid }}" \
            --arg classification "${{ steps.validate.outputs.classification }}" \
            --arg check_spec "${{ steps.validate.outputs.check_spec_exists }}" \
            --arg check_code "${{ steps.validate.outputs.check_no_code }}" \
            --arg check_class "${{ steps.validate.outputs.check_classification }}" \
            --arg check_prob "${{ steps.validate.outputs.check_problem }}" \
            --arg check_appr "${{ steps.validate.outputs.check_approach }}" \
            --arg check_act "${{ steps.validate.outputs.check_actionable }}" \
            --arg non_spec "${{ steps.validate.outputs.non_spec_count }}" \
            '{
              schema_version: $schema_version,
              stage: $stage,
              issue_number: ($issue_number | tonumber? // 0),
              spec_pr_number: ($spec_pr_number | tonumber? // 0),
              timestamp: $timestamp,
              spec: {
                valid: ($valid == "true"),
                classification: $classification,
                checks: {
                  spec_exists: ($check_spec == "true"),
                  no_code_changes: ($check_code == "true"),
                  has_classification: ($check_class == "true"),
                  has_problem_analysis: ($check_prob == "true"),
                  has_approach: ($check_appr == "true"),
                  is_actionable: ($check_act == "true")
                },
                non_spec_file_count: ($non_spec | tonumber? // 0)
              },
              timing: {
                pr_created_at: $pr_created_at,
                validated_at: $timestamp
              }
            }' > "$METRICS_FILE" || true

          echo "=== Agent Metrics (Spec Validate) ==="
          cat "$METRICS_FILE" 2>/dev/null || echo "Failed to generate metrics"

      - name: Upload agent metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: agent-metrics-spec-${{ steps.issue.outputs.number }}
          path: /tmp/agent-metrics-spec-*.json
          retention-days: 90
          if-no-files-found: ignore

      - name: Comment on validation failure
        if: steps.validate.outputs.valid == 'false'
        env:
          GH_TOKEN: ${{ secrets.PUSH_TOKEN }}
        run: |
          PR_NUM="${{ github.event.pull_request.number }}"
          REASON="${{ steps.validate.outputs.reason }}"
          
          gh pr comment $PR_NUM --body "## Spec Validation Failed ❌

          This spec PR could not be auto-approved:

          $REASON

          ---
          
          Please address these issues or wait for human review."
          
          echo "Posted validation failure comment"

  # ── Scheduled scan: catches spec PRs blocked by actor-approval gate ──
  # GitHub blocks pull_request_target runs from the Copilot bot with
  # "action_required". This cron scans for unapproved spec PRs and
  # validates them using the GitHub API (no git checkout needed).
  scan:
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: Scan and validate spec PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PUSH_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Find open PRs with "spec:" in the title, targeting main
            const { data: openPRs } = await github.rest.pulls.list({
              owner, repo,
              state: 'open',
              base: 'main',
              per_page: 100,
            });

            const specPRs = openPRs.filter(pr =>
              !pr.draft &&
              pr.title.toLowerCase().includes('spec:') &&
              !pr.labels.some(l => l.name === 'approved-for-build')
            );

            if (specPRs.length === 0) {
              core.info('No unapproved spec PRs found');
              return;
            }

            core.info(`Found ${specPRs.length} spec PR(s) to validate`);

            for (const pr of specPRs) {
              try {
                // Skip if already approved
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner, repo,
                  pull_number: pr.number,
                });
                if (reviews.some(r => r.state === 'APPROVED')) {
                  core.info(`PR #${pr.number}: already approved, skipping`);
                  continue;
                }

                // Extract issue number from title
                const match = pr.title.match(/Issue #(\d+)/i);
                if (!match) {
                  core.info(`PR #${pr.number}: no issue number in title, skipping`);
                  continue;
                }
                const issueNum = match[1];

                // Get list of changed files
                const { data: files } = await github.rest.pulls.listFiles({
                  owner, repo,
                  pull_number: pr.number,
                });

                const filePaths = files.map(f => f.filename);
                const specFile = `specs/issue-${issueNum}-spec.md`;

                // Check 1: Spec file exists in the PR
                if (!filePaths.includes(specFile)) {
                  core.info(`PR #${pr.number}: spec file ${specFile} not in changed files, skipping`);
                  continue;
                }

                // Check 2: No code changes (only specs/ and .github/workflows/ allowed)
                const codeFiles = filePaths.filter(
                  f => !f.startsWith('specs/') && !f.startsWith('.github/workflows/')
                );
                if (codeFiles.length > 0) {
                  core.info(`PR #${pr.number}: contains code files: ${codeFiles.join(', ')}, skipping`);
                  continue;
                }

                // Check 3: Fetch spec file content and validate sections
                let specContent = '';
                try {
                  const { data: fileData } = await github.rest.repos.getContent({
                    owner, repo,
                    path: specFile,
                    ref: pr.head.ref,
                  });
                  specContent = Buffer.from(fileData.content, 'base64').toString('utf-8');
                } catch (e) {
                  core.info(`PR #${pr.number}: could not fetch ${specFile}: ${e.message}`);
                  continue;
                }

                const hasClassification = specContent.includes('## Classification');
                const hasProblem = specContent.includes('## Problem Analysis');
                const hasApproach = specContent.includes('## Proposed Approach');

                if (!hasClassification || !hasProblem || !hasApproach) {
                  const missing = [];
                  if (!hasClassification) missing.push('Classification');
                  if (!hasProblem) missing.push('Problem Analysis');
                  if (!hasApproach) missing.push('Proposed Approach');
                  core.info(`PR #${pr.number}: missing sections: ${missing.join(', ')}`);
                  continue;
                }

                // Check 4: Classification is actionable
                const classMatch = specContent.match(/## Classification\s*\n+([^\n#]+)/);
                const classification = classMatch ? classMatch[1].trim().toLowerCase() : '';
                if (/wont.?do|needs.?info/i.test(classification)) {
                  core.info(`PR #${pr.number}: non-actionable classification: ${classification}`);
                  continue;
                }

                // All checks passed — approve and trigger Goose
                core.info(`PR #${pr.number}: all checks passed, approving`);

                await github.rest.pulls.createReview({
                  owner, repo,
                  pull_number: pr.number,
                  event: 'APPROVE',
                  body: [
                    '## Auto-Approved ✅',
                    '',
                    'This spec PR passed all validation checks (via scheduled scan):',
                    '',
                    `- ✅ Spec file exists at \`${specFile}\``,
                    '- ✅ Required sections present (Classification, Problem Analysis, Proposed Approach)',
                    '- ✅ No code changes detected',
                    `- ✅ Classification is actionable: ${classification}`,
                    '',
                    'Goose will now implement the code based on this specification.',
                  ].join('\n'),
                });

                await github.rest.issues.addLabels({
                  owner, repo,
                  issue_number: pr.number,
                  labels: ['approved-for-build'],
                });

                await github.rest.actions.createWorkflowDispatch({
                  owner, repo,
                  workflow_id: 'goose-build.yml',
                  ref: 'main',
                  inputs: {
                    issue_number: issueNum,
                    spec_pr_number: String(pr.number),
                  },
                });

                core.info(`PR #${pr.number}: approved + Goose triggered for issue #${issueNum}`);

              } catch (err) {
                core.warning(`PR #${pr.number}: error: ${err.message}`);
              }
            }
