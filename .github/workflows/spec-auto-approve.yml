name: Spec Auto-Approve

# Validates and auto-approves Copilot spec PRs that pass all checks.
# This triggers Goose implementation automatically, reducing manual work.
#
# Checks:
#   1. Spec file exists at specs/issue-N-spec.md
#   2. Required sections present (Classification, Problem Analysis, Proposed Approach)
#   3. No code changes (only spec file in PR)
#   4. Classification is actionable (not wont-do or needs-info)
#
# Uses pull_request_target to run on Copilot PRs without action_required blocking.

on:
  pull_request_target:
    types: [opened, ready_for_review, edited]
    branches: [main]

permissions:
  pull-requests: write
  contents: read
  issues: write

jobs:
  validate:
    if: contains(github.event.pull_request.title, 'spec:')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Fetch PR changes
        env:
          GH_TOKEN: ${{ secrets.PUSH_TOKEN }}
        run: |
          gh pr checkout ${{ github.event.pull_request.number }} --detach
          git checkout ${{ github.event.pull_request.head.ref }}

      - name: Extract issue number
        id: issue
        run: |
          TITLE="${{ github.event.pull_request.title }}"
          ISSUE_NUM=$(echo "$TITLE" | grep -oP 'Issue #\K\d+' || true)
          if [ -z "$ISSUE_NUM" ]; then
            echo "::error::Could not extract issue number from PR title: $TITLE"
            exit 1
          fi
          echo "number=$ISSUE_NUM" >> $GITHUB_OUTPUT
          echo "Issue number: $ISSUE_NUM"

      - name: Validate spec
        id: validate
        env:
          ISSUE_NUM: ${{ steps.issue.outputs.number }}
        run: |
          SPEC_FILE="specs/issue-${ISSUE_NUM}-spec.md"
          REASONS=""

          # Agent metrics: track per-check results
          CHECK_SPEC_EXISTS=false
          CHECK_NO_CODE=false
          CHECK_CLASSIFICATION=false
          CHECK_PROBLEM=false
          CHECK_APPROACH=false
          CHECK_ACTIONABLE=false
          CLASSIFICATION_VALUE=""
          NON_SPEC_COUNT=0

          # Check 1: Spec file exists
          if [ ! -f "$SPEC_FILE" ]; then
            REASONS="${REASONS}- Spec file not found: $SPEC_FILE\n"
          else
            CHECK_SPEC_EXISTS=true
          fi

          # Check 2: No code changes (only spec file should be modified)
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
          CODE_FILES=$(echo "$CHANGED_FILES" | grep -v "^specs/" | grep -v "^\.github/workflows/" || true)
          if [ -n "$CODE_FILES" ]; then
            NON_SPEC_COUNT=$(echo "$CODE_FILES" | grep -c . || echo 0)
            REASONS="${REASONS}- PR contains non-spec file changes:\n$CODE_FILES\n"
          else
            CHECK_NO_CODE=true
          fi

          # Check 3: Required sections present
          if [ -f "$SPEC_FILE" ]; then
            CONTENT=$(cat "$SPEC_FILE")
            
            if echo "$CONTENT" | grep -q "## Classification"; then
              CHECK_CLASSIFICATION=true
            else
              REASONS="${REASONS}- Missing required section: ## Classification\n"
            fi
            
            if echo "$CONTENT" | grep -q "## Problem Analysis"; then
              CHECK_PROBLEM=true
            else
              REASONS="${REASONS}- Missing required section: ## Problem Analysis\n"
            fi
            
            if echo "$CONTENT" | grep -q "## Proposed Approach"; then
              CHECK_APPROACH=true
            else
              REASONS="${REASONS}- Missing required section: ## Proposed Approach\n"
            fi

            # Check 4: Classification is actionable (not wont-do or needs-info)
            CLASSIFICATION_VALUE=$(echo "$CONTENT" | grep -A1 "## Classification" | tail -1 | tr '[:upper:]' '[:lower:]' | xargs || true)
            if echo "$CLASSIFICATION_VALUE" | grep -qiE "wont-do|wont do|needs-info|needs info"; then
              REASONS="${REASONS}- Classification requires human review: $CLASSIFICATION_VALUE\n"
            else
              CHECK_ACTIONABLE=true
            fi
          fi

          # Export check results for metrics
          echo "check_spec_exists=$CHECK_SPEC_EXISTS" >> $GITHUB_OUTPUT
          echo "check_no_code=$CHECK_NO_CODE" >> $GITHUB_OUTPUT
          echo "check_classification=$CHECK_CLASSIFICATION" >> $GITHUB_OUTPUT
          echo "check_problem=$CHECK_PROBLEM" >> $GITHUB_OUTPUT
          echo "check_approach=$CHECK_APPROACH" >> $GITHUB_OUTPUT
          echo "check_actionable=$CHECK_ACTIONABLE" >> $GITHUB_OUTPUT
          echo "classification=$CLASSIFICATION_VALUE" >> $GITHUB_OUTPUT
          echo "non_spec_count=$NON_SPEC_COUNT" >> $GITHUB_OUTPUT

          # Result
          if [ -z "$REASONS" ]; then
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "reason=" >> $GITHUB_OUTPUT
            echo "All validation checks passed"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "reason<<EOF" >> $GITHUB_OUTPUT
            echo -e "$REASONS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "Validation failed"
            echo -e "$REASONS"
          fi

      - name: Auto-approve and trigger Goose
        if: steps.validate.outputs.valid == 'true'
        env:
          GH_TOKEN: ${{ secrets.PUSH_TOKEN }}
          ISSUE_NUM: ${{ steps.issue.outputs.number }}
        run: |
          PR_NUM="${{ github.event.pull_request.number }}"
          REVIEWER="${{ github.actor }}"
          
          echo "Auto-approving spec PR #$PR_NUM"
          
          # Approve the PR
          gh pr review $PR_NUM --approve --body "## Auto-Approved ✅

          This spec PR passed all validation checks:
          
          - ✅ Spec file exists at \`specs/issue-${ISSUE_NUM}-spec.md\`
          - ✅ Required sections present (Classification, Problem Analysis, Proposed Approach)
          - ✅ No code changes detected
          - ✅ Classification is actionable
          
          Goose will now implement the code based on this specification."
          
          # Add the label for tracking
          gh pr edit $PR_NUM --add-label approved-for-build
          
          # Directly trigger Goose implementation via workflow_dispatch.
          # Labels added by workflows don't fire pull_request events (GitHub limitation),
          # so we invoke goose-build.yml explicitly instead of relying on the labeled trigger.
          echo "Triggering Goose implementation for issue #${ISSUE_NUM} (spec PR #${PR_NUM})"
          gh workflow run goose-build.yml \
            -f issue_number="${ISSUE_NUM}" \
            -f spec_pr_number="${PR_NUM}"
          
          echo "Goose implementation triggered"

      # ── Agent metrics: spec validation ────────────────
      - name: Collect agent metrics
        if: always()
        env:
          ISSUE_NUM: ${{ steps.issue.outputs.number }}
        run: |
          METRICS_FILE="/tmp/agent-metrics-spec-${ISSUE_NUM}.json"
          PR_CREATED="${{ github.event.pull_request.created_at }}"

          jq -n \
            --argjson schema_version 1 \
            --arg stage "spec_validate" \
            --arg issue_number "$ISSUE_NUM" \
            --arg spec_pr_number "${{ github.event.pull_request.number }}" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg pr_created_at "$PR_CREATED" \
            --arg valid "${{ steps.validate.outputs.valid }}" \
            --arg classification "${{ steps.validate.outputs.classification }}" \
            --arg check_spec "${{ steps.validate.outputs.check_spec_exists }}" \
            --arg check_code "${{ steps.validate.outputs.check_no_code }}" \
            --arg check_class "${{ steps.validate.outputs.check_classification }}" \
            --arg check_prob "${{ steps.validate.outputs.check_problem }}" \
            --arg check_appr "${{ steps.validate.outputs.check_approach }}" \
            --arg check_act "${{ steps.validate.outputs.check_actionable }}" \
            --arg non_spec "${{ steps.validate.outputs.non_spec_count }}" \
            '{
              schema_version: $schema_version,
              stage: $stage,
              issue_number: ($issue_number | tonumber? // 0),
              spec_pr_number: ($spec_pr_number | tonumber? // 0),
              timestamp: $timestamp,
              spec: {
                valid: ($valid == "true"),
                classification: $classification,
                checks: {
                  spec_exists: ($check_spec == "true"),
                  no_code_changes: ($check_code == "true"),
                  has_classification: ($check_class == "true"),
                  has_problem_analysis: ($check_prob == "true"),
                  has_approach: ($check_appr == "true"),
                  is_actionable: ($check_act == "true")
                },
                non_spec_file_count: ($non_spec | tonumber? // 0)
              },
              timing: {
                pr_created_at: $pr_created_at,
                validated_at: $timestamp
              }
            }' > "$METRICS_FILE" || true

          echo "=== Agent Metrics (Spec Validate) ==="
          cat "$METRICS_FILE" 2>/dev/null || echo "Failed to generate metrics"

      - name: Upload agent metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: agent-metrics-spec-${{ steps.issue.outputs.number }}
          path: /tmp/agent-metrics-spec-*.json
          retention-days: 90
          if-no-files-found: ignore

      - name: Comment on validation failure
        if: steps.validate.outputs.valid == 'false'
        env:
          GH_TOKEN: ${{ secrets.PUSH_TOKEN }}
        run: |
          PR_NUM="${{ github.event.pull_request.number }}"
          REASON="${{ steps.validate.outputs.reason }}"
          
          gh pr comment $PR_NUM --body "## Spec Validation Failed ❌

          This spec PR could not be auto-approved:

          $REASON

          ---
          
          Please address these issues or wait for human review."
          
          echo "Posted validation failure comment"
