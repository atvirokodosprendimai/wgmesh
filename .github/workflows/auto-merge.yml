name: Auto-merge on CI pass

# Auto-approves and squash-merges non-draft PRs to main when all CI checks pass.
# Uses a GitHub App (wgmesh-bot) so the approval comes from a distinct identity,
# bypassing the "cannot approve your own PR" restriction.

on:
  # Fires when CI workflows complete on PRs
  workflow_run:
    workflows: ["Build and Push Docker Images"]
    types: [completed]
  # Also fires when a draft PR is marked ready for review
  pull_request:
    types: [ready_for_review]
  # Periodic fallback to catch PRs where timing caused a miss
  schedule:
    - cron: '*/10 * * * *'
  # Manual trigger for on-demand runs
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Auto-approve and merge eligible PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            // Collect candidate PRs based on event type
            let candidates = [];

            if (context.eventName === 'workflow_run') {
              const run = context.payload.workflow_run;
              if (run.conclusion !== 'success') {
                core.info(`Workflow run conclusion: ${run.conclusion}, skipping`);
                return;
              }
              candidates = (run.pull_requests || []).map(p => p.number);
              if (candidates.length === 0) {
                core.info('No PRs associated with this workflow run');
                return;
              }
            } else if (context.eventName === 'pull_request') {
              const pr = context.payload.pull_request;
              if (pr.draft) {
                core.info('PR is still a draft, skipping');
                return;
              }
              candidates = [pr.number];
            } else if (context.eventName === 'schedule') {
              const { data: openPRs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                base: 'main',
                per_page: 50,
              });
              candidates = openPRs.filter(p => !p.draft).map(p => p.number);
              if (candidates.length === 0) {
                core.info('No open non-draft PRs targeting main');
                return;
              }
              core.info(`Schedule: checking ${candidates.length} open PRs`);
            }

            for (const prNumber of candidates) {
              try {
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });

                if (pr.draft || pr.state !== 'open' || pr.base.ref !== 'main') {
                  core.info(`PR #${prNumber}: draft=${pr.draft} state=${pr.state} base=${pr.base.ref}, skipping`);
                  continue;
                }

                // Check if already approved
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });
                const hasApproval = reviews.some(r => r.state === 'APPROVED');

                // Verify ALL check runs passed
                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: pr.head.sha,
                });

                const relevant = checkRuns.check_runs.filter(
                  cr => cr.name !== 'auto-merge' &&
                        cr.name !== 'Auto-merge on CI pass' &&
                        cr.name !== 'sync'
                );

                if (relevant.length === 0) {
                  core.info(`PR #${prNumber}: no relevant checks found yet`);
                  continue;
                }

                const allComplete = relevant.every(cr => cr.status === 'completed');
                const allPassed = relevant.every(
                  cr => cr.conclusion === 'success' || cr.conclusion === 'skipped'
                );

                if (!allComplete) {
                  core.info(`PR #${prNumber}: ${relevant.filter(cr => cr.status !== 'completed').map(cr => cr.name).join(', ')} still running`);
                  continue;
                }

                if (!allPassed) {
                  const failed = relevant
                    .filter(cr => cr.conclusion !== 'success' && cr.conclusion !== 'skipped')
                    .map(cr => `${cr.name}: ${cr.conclusion}`);
                  core.info(`PR #${prNumber}: failing: ${failed.join(', ')}`);
                  continue;
                }

                core.info(`PR #${prNumber}: all ${relevant.length} checks passed`);

                // Approve if needed
                if (!hasApproval) {
                  await github.rest.pulls.createReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    event: 'APPROVE',
                    body: 'Auto-approved: all CI checks passed.',
                  });
                  core.info(`PR #${prNumber}: approved`);
                }

                // Squash-merge directly â€” GitHub rejects enablePullRequestAutoMerge
                // when the PR is already in 'clean' (immediately mergeable) state.
                try {
                  await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    merge_method: 'squash',
                  });
                  core.info(`PR #${prNumber}: squash-merged`);
                } catch (mergeErr) {
                  core.warning(`PR #${prNumber}: failed to merge: ${mergeErr.message}`);
                }

              } catch (err) {
                core.warning(`PR #${prNumber}: error: ${err.message}`);
              }
            }
