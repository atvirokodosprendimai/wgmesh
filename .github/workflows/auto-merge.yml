name: Auto-merge on CI pass

# Auto-approves and squash-merges non-draft PRs to main when all CI checks pass.
# Uses a GitHub App (wgmesh-bot) so the approval comes from a distinct identity,
# bypassing the "cannot approve your own PR" restriction.
#
# When a PR branch is behind main, the workflow updates it automatically.
# After a branch update, CI re-runs and the next cycle merges the PR.

on:
  # Fires when CI workflows complete on PRs
  workflow_run:
    workflows: ["Build and Push Docker Images", "CodeQL"]
    types: [completed]
  # Also fires when a draft PR is marked ready for review
  pull_request:
    types: [ready_for_review]
  # Periodic fallback to catch PRs where timing caused a miss
  schedule:
    - cron: '*/10 * * * *'
  # Manual trigger for on-demand runs
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Auto-approve and merge eligible PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const fs = require('fs');

            // Agent metrics: collect per-PR merge data
            const mergeMetrics = [];

            // Collect candidate PRs based on event type
            let candidates = [];

            if (context.eventName === 'workflow_run') {
              const run = context.payload.workflow_run;
              if (run.conclusion !== 'success') {
                core.info(`Workflow run conclusion: ${run.conclusion}, skipping`);
                return;
              }
              candidates = (run.pull_requests || []).map(p => p.number);
              if (candidates.length === 0) {
                core.info('No PRs associated with this workflow run');
                return;
              }
            } else if (context.eventName === 'pull_request') {
              const pr = context.payload.pull_request;
              if (pr.draft) {
                core.info('PR is still a draft, skipping');
                return;
              }
              candidates = [pr.number];
            } else if (context.eventName === 'schedule' || context.eventName === 'workflow_dispatch') {
              const { data: openPRs } = await github.rest.pulls.list({
                owner, repo,
                state: 'open',
                base: 'main',
                per_page: 50,
              });
              candidates = openPRs.filter(p => !p.draft).map(p => p.number);
              if (candidates.length === 0) {
                core.info('No open non-draft PRs targeting main');
                return;
              }
              core.info(`${context.eventName}: checking ${candidates.length} open PRs`);
            }

            // Process PRs sequentially — merging one PR into main can affect others
            for (const prNumber of candidates) {
              try {
                const { data: pr } = await github.rest.pulls.get({
                  owner, repo,
                  pull_number: prNumber,
                });

                if (pr.draft || pr.state !== 'open' || pr.base.ref !== 'main') {
                  core.info(`PR #${prNumber}: draft=${pr.draft} state=${pr.state} base=${pr.base.ref}, skipping`);
                  continue;
                }

                // --- Branch freshness check ---
                // GitHub may return mergeable=null if it hasn't computed yet.
                // The mergeable_state tells us if the branch is behind main.
                if (pr.mergeable === false) {
                  core.info(`PR #${prNumber}: has conflicts, attempting branch update`);
                  try {
                    await github.rest.pulls.updateBranch({
                      owner, repo,
                      pull_number: prNumber,
                    });
                    core.info(`PR #${prNumber}: branch updated with latest main — CI will re-run`);
                  } catch (updateErr) {
                    // If update fails, there's a real conflict that needs manual resolution
                    core.warning(`PR #${prNumber}: branch update failed (conflicts): ${updateErr.message}`);

                    // Add 'conflict' label if not already present
                    const labels = pr.labels.map(l => l.name);
                    if (!labels.includes('conflict')) {
                      try {
                        await github.rest.issues.addLabels({
                          owner, repo,
                          issue_number: prNumber,
                          labels: ['conflict'],
                        });
                      } catch (labelErr) {
                        core.info(`PR #${prNumber}: could not add 'conflict' label: ${labelErr.message}`);
                      }
                    }
                  }
                  continue; // Skip merge attempt — wait for CI to re-run after update
                }

                // mergeable=null means GitHub hasn't computed it yet — skip for now
                if (pr.mergeable === null) {
                  core.info(`PR #${prNumber}: mergeable state not yet computed, will retry next cycle`);
                  continue;
                }

                // Check if already approved
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner, repo,
                  pull_number: prNumber,
                });
                const hasApproval = reviews.some(r => r.state === 'APPROVED');

                // Verify ALL check runs passed
                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner, repo,
                  ref: pr.head.sha,
                });

                const relevant = checkRuns.check_runs.filter(
                  cr => cr.name !== 'auto-merge' &&
                        cr.name !== 'Auto-merge on CI pass' &&
                        cr.name !== 'sync' &&
                        cr.name !== 'Cloud Integration Tests' &&
                        cr.name !== 'Cleanup Orphaned VMs'
                );

                if (relevant.length === 0) {
                  core.info(`PR #${prNumber}: no relevant checks found yet`);
                  continue;
                }

                const allComplete = relevant.every(cr => cr.status === 'completed');
                const allPassed = relevant.every(
                  cr => cr.conclusion === 'success' || cr.conclusion === 'skipped'
                );

                if (!allComplete) {
                  core.info(`PR #${prNumber}: ${relevant.filter(cr => cr.status !== 'completed').map(cr => cr.name).join(', ')} still running`);
                  continue;
                }

                if (!allPassed) {
                  const failed = relevant
                    .filter(cr => cr.conclusion !== 'success' && cr.conclusion !== 'skipped')
                    .map(cr => `${cr.name}: ${cr.conclusion}`);
                  core.info(`PR #${prNumber}: failing: ${failed.join(', ')}`);
                  continue;
                }

                core.info(`PR #${prNumber}: all ${relevant.length} checks passed`);

                // --- Review quality gate ---
                // Block merge if there are unresolved review threads or CHANGES_REQUESTED
                const hasChangesRequested = reviews.some(
                  r => r.state === 'CHANGES_REQUESTED'
                );
                if (hasChangesRequested) {
                  core.info(`PR #${prNumber}: has CHANGES_REQUESTED review, skipping until resolved`);
                  continue;
                }

                // Check for unresolved review threads via GraphQL
                // Auto-resolve threads from Copilot (AI reviewer) — these are informational,
                // not human blockers. Human CHANGES_REQUESTED is already caught above.
                const prGql = await github.graphql(`
                  query($owner: String!, $repo: String!, $number: Int!) {
                    repository(owner: $owner, name: $repo) {
                      pullRequest(number: $number) {
                        reviewThreads(first: 100) {
                          nodes {
                            id
                            isResolved
                            comments(first: 1) {
                              nodes { body author { login } }
                            }
                          }
                        }
                      }
                    }
                  }
                `, { owner, repo, number: prNumber });

                const threads = prGql.repository.pullRequest.reviewThreads.nodes;
                const unresolvedThreads = threads.filter(t => !t.isResolved);

                // Unresolved review threads block merge.
                // Copilot threads are not auto-resolved — Goose must address them.
                if (unresolvedThreads.length > 0) {
                  const byAuthor = unresolvedThreads
                    .map(t => t.comments.nodes[0]?.author?.login || 'unknown')
                    .filter((v, i, a) => a.indexOf(v) === i);
                  const copilotThreads = unresolvedThreads.filter(t => {
                    const login = t.comments.nodes[0]?.author?.login || '';
                    return login.includes('copilot') || login.includes('bot');
                  });

                  core.info(`PR #${prNumber}: ${unresolvedThreads.length} unresolved thread(s) from ${byAuthor.join(', ')}`);

                  // Dispatch goose-review to address Copilot feedback on the PR branch
                  if (copilotThreads.length > 0) {
                    try {
                      await github.rest.actions.createWorkflowDispatch({
                        owner, repo,
                        workflow_id: 'goose-review.yml',
                        ref: 'main',
                        inputs: { pr_number: String(prNumber) },
                      });
                      core.info(`PR #${prNumber}: dispatched goose-review to address ${copilotThreads.length} Copilot thread(s)`);
                    } catch (dispatchErr) {
                      core.warning(`PR #${prNumber}: could not dispatch goose-review: ${dispatchErr.message}`);
                    }
                  }

                  continue; // block merge until threads are resolved
                }
                core.info(`PR #${prNumber}: all review threads resolved`);

                // Remove 'conflict' label if present (branch is now clean)
                const labels = pr.labels.map(l => l.name);
                if (labels.includes('conflict')) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner, repo,
                      issue_number: prNumber,
                      name: 'conflict',
                    });
                    core.info(`PR #${prNumber}: removed 'conflict' label`);
                  } catch (rmErr) {
                    // Label may already be removed
                  }
                }

                // Approve if needed
                if (!hasApproval) {
                  await github.rest.pulls.createReview({
                    owner, repo,
                    pull_number: prNumber,
                    event: 'APPROVE',
                    body: 'Auto-approved: all CI checks passed.',
                  });
                  core.info(`PR #${prNumber}: approved`);
                }

                // Squash-merge directly — GitHub rejects enablePullRequestAutoMerge
                // when the PR is already in 'clean' (immediately mergeable) state.
                let mergeResult = { succeeded: false, method: 'squash' };
                try {
                  await github.rest.pulls.merge({
                    owner, repo,
                    pull_number: prNumber,
                    merge_method: 'squash',
                  });
                  core.info(`PR #${prNumber}: squash-merged`);
                  mergeResult.succeeded = true;
                } catch (mergeErr) {
                  core.warning(`PR #${prNumber}: failed to merge: ${mergeErr.message}`);
                  mergeResult.error = mergeErr.message;
                }

                // Agent metrics: collect review burden (Copilot + human comments)
                let reviewBurden = { copilot_comments: 0, human_comments: 0, total_reviews: 0 };
                try {
                  const { data: prComments } = await github.rest.pulls.listReviewComments({
                    owner, repo, pull_number: prNumber, per_page: 100,
                  });
                  reviewBurden.copilot_comments = prComments.filter(
                    c => c.user?.login?.includes('copilot') || c.user?.login?.includes('bot')
                  ).length;
                  reviewBurden.human_comments = prComments.length - reviewBurden.copilot_comments;
                  reviewBurden.total_reviews = reviews.length;
                } catch (e) { /* non-fatal */ }

                // Agent metrics: record this PR
                mergeMetrics.push({
                  schema_version: 1,
                  stage: 'auto_merge',
                  pr_number: prNumber,
                  timestamp: new Date().toISOString(),
                  pr: {
                    author: pr.user?.login || 'unknown',
                    labels: pr.labels.map(l => l.name),
                    created_at: pr.created_at,
                    merged_at: mergeResult.succeeded ? new Date().toISOString() : null,
                    pr_age_seconds: mergeResult.succeeded
                      ? Math.round((Date.now() - new Date(pr.created_at).getTime()) / 1000)
                      : null,
                  },
                  checks: {
                    total: relevant.length,
                    passed: relevant.filter(cr => cr.conclusion === 'success').length,
                    failed: relevant.filter(cr => cr.conclusion !== 'success' && cr.conclusion !== 'skipped').length,
                    failed_names: relevant
                      .filter(cr => cr.conclusion !== 'success' && cr.conclusion !== 'skipped')
                      .map(cr => cr.name),
                  },
                  merge: mergeResult,
                  review_burden: reviewBurden,
                });

              } catch (err) {
                core.warning(`PR #${prNumber}: error: ${err.message}`);
              }
            }

            // Agent metrics: write collected data (use run_id in filename to avoid overwrite on extraction)
            if (mergeMetrics.length > 0) {
              const metricsPath = `/tmp/agent-metrics-merge-${process.env.GITHUB_RUN_ID}.json`;
              fs.writeFileSync(metricsPath, JSON.stringify(mergeMetrics, null, 2) + '\n');
              core.info(`Agent metrics: wrote ${mergeMetrics.length} PR records to ${metricsPath}`);
            }

      - name: Upload agent metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: agent-metrics-merge-${{ github.run_id }}
          path: /tmp/agent-metrics-merge-${{ github.run_id }}.json
          retention-days: 90
          if-no-files-found: ignore
