name: Auto-merge on CI pass

# Auto-approves and squash-merges non-draft PRs to main when all CI checks pass.
# Uses a GitHub App (wgmesh-bot) so the approval comes from a distinct identity,
# bypassing the "cannot approve your own PR" restriction.
#
# When a PR branch is behind main, the workflow updates it automatically.
# After a branch update, CI re-runs and the next cycle merges the PR.

on:
  # Fires when CI workflows complete on PRs
  workflow_run:
    workflows: ["Build and Push Docker Images", "CodeQL"]
    types: [completed]
  # Also fires when a draft PR is marked ready for review
  pull_request:
    types: [ready_for_review]
  # Periodic fallback to catch PRs where timing caused a miss
  schedule:
    - cron: '*/10 * * * *'
  # Manual trigger for on-demand runs
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Auto-approve and merge eligible PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Collect candidate PRs based on event type
            let candidates = [];

            if (context.eventName === 'workflow_run') {
              const run = context.payload.workflow_run;
              if (run.conclusion !== 'success') {
                core.info(`Workflow run conclusion: ${run.conclusion}, skipping`);
                return;
              }
              candidates = (run.pull_requests || []).map(p => p.number);
              if (candidates.length === 0) {
                core.info('No PRs associated with this workflow run');
                return;
              }
            } else if (context.eventName === 'pull_request') {
              const pr = context.payload.pull_request;
              if (pr.draft) {
                core.info('PR is still a draft, skipping');
                return;
              }
              candidates = [pr.number];
            } else if (context.eventName === 'schedule' || context.eventName === 'workflow_dispatch') {
              const { data: openPRs } = await github.rest.pulls.list({
                owner, repo,
                state: 'open',
                base: 'main',
                per_page: 50,
              });
              candidates = openPRs.filter(p => !p.draft).map(p => p.number);
              if (candidates.length === 0) {
                core.info('No open non-draft PRs targeting main');
                return;
              }
              core.info(`${context.eventName}: checking ${candidates.length} open PRs`);
            }

            // Process PRs sequentially — merging one PR into main can affect others
            for (const prNumber of candidates) {
              try {
                const { data: pr } = await github.rest.pulls.get({
                  owner, repo,
                  pull_number: prNumber,
                });

                if (pr.draft || pr.state !== 'open' || pr.base.ref !== 'main') {
                  core.info(`PR #${prNumber}: draft=${pr.draft} state=${pr.state} base=${pr.base.ref}, skipping`);
                  continue;
                }

                // --- Branch freshness check ---
                // GitHub may return mergeable=null if it hasn't computed yet.
                // The mergeable_state tells us if the branch is behind main.
                if (pr.mergeable === false) {
                  core.info(`PR #${prNumber}: has conflicts, attempting branch update`);
                  try {
                    await github.rest.pulls.updateBranch({
                      owner, repo,
                      pull_number: prNumber,
                    });
                    core.info(`PR #${prNumber}: branch updated with latest main — CI will re-run`);
                  } catch (updateErr) {
                    // If update fails, there's a real conflict that needs manual resolution
                    core.warning(`PR #${prNumber}: branch update failed (conflicts): ${updateErr.message}`);

                    // Add 'conflict' label if not already present
                    const labels = pr.labels.map(l => l.name);
                    if (!labels.includes('conflict')) {
                      try {
                        await github.rest.issues.addLabels({
                          owner, repo,
                          issue_number: prNumber,
                          labels: ['conflict'],
                        });
                      } catch (labelErr) {
                        core.info(`PR #${prNumber}: could not add 'conflict' label: ${labelErr.message}`);
                      }
                    }
                  }
                  continue; // Skip merge attempt — wait for CI to re-run after update
                }

                // mergeable=null means GitHub hasn't computed it yet — skip for now
                if (pr.mergeable === null) {
                  core.info(`PR #${prNumber}: mergeable state not yet computed, will retry next cycle`);
                  continue;
                }

                // Check if already approved
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner, repo,
                  pull_number: prNumber,
                });
                const hasApproval = reviews.some(r => r.state === 'APPROVED');

                // Verify ALL check runs passed
                const { data: checkRuns } = await github.rest.checks.listForRef({
                  owner, repo,
                  ref: pr.head.sha,
                });

                const relevant = checkRuns.check_runs.filter(
                  cr => cr.name !== 'auto-merge' &&
                        cr.name !== 'Auto-merge on CI pass' &&
                        cr.name !== 'sync' &&
                        cr.name !== 'Cloud Integration Tests' &&
                        cr.name !== 'Cleanup Orphaned VMs'
                );

                if (relevant.length === 0) {
                  core.info(`PR #${prNumber}: no relevant checks found yet`);
                  continue;
                }

                const allComplete = relevant.every(cr => cr.status === 'completed');
                const allPassed = relevant.every(
                  cr => cr.conclusion === 'success' || cr.conclusion === 'skipped'
                );

                if (!allComplete) {
                  core.info(`PR #${prNumber}: ${relevant.filter(cr => cr.status !== 'completed').map(cr => cr.name).join(', ')} still running`);
                  continue;
                }

                if (!allPassed) {
                  const failed = relevant
                    .filter(cr => cr.conclusion !== 'success' && cr.conclusion !== 'skipped')
                    .map(cr => `${cr.name}: ${cr.conclusion}`);
                  core.info(`PR #${prNumber}: failing: ${failed.join(', ')}`);
                  continue;
                }

                core.info(`PR #${prNumber}: all ${relevant.length} checks passed`);

                // Remove 'conflict' label if present (branch is now clean)
                const labels = pr.labels.map(l => l.name);
                if (labels.includes('conflict')) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner, repo,
                      issue_number: prNumber,
                      name: 'conflict',
                    });
                    core.info(`PR #${prNumber}: removed 'conflict' label`);
                  } catch (rmErr) {
                    // Label may already be removed
                  }
                }

                // Approve if needed
                if (!hasApproval) {
                  await github.rest.pulls.createReview({
                    owner, repo,
                    pull_number: prNumber,
                    event: 'APPROVE',
                    body: 'Auto-approved: all CI checks passed.',
                  });
                  core.info(`PR #${prNumber}: approved`);
                }

                // Squash-merge directly — GitHub rejects enablePullRequestAutoMerge
                // when the PR is already in 'clean' (immediately mergeable) state.
                try {
                  await github.rest.pulls.merge({
                    owner, repo,
                    pull_number: prNumber,
                    merge_method: 'squash',
                  });
                  core.info(`PR #${prNumber}: squash-merged`);
                } catch (mergeErr) {
                  core.warning(`PR #${prNumber}: failed to merge: ${mergeErr.message}`);
                }

              } catch (err) {
                core.warning(`PR #${prNumber}: error: ${err.message}`);
              }
            }
